1 ОПИС АРХІТЕКТУРИ IOT ЧАСТИНИ
     
	Для написання IoT частини системи було обрано мову програмування C++ для Arduino. У якості середовища розробки обрано Arduino IDE, оскільки воно надає необхідні бібліотеки для роботи з мікроконтролером Arduino.
	Для програмування різних частин мікроконтролера Arduino Uno були використані бібліотеки SoftwareSerial, ArduinoUniqueID, TinyGPS++, MPU6050, ArduinoJSON.
	Для програмування різних частин WiFi модуля ESP8266 були використані бібліотеки ESP8266WiFi, ESP8266HTTPClient, WiFiClientSecure, ArduinoJSON.
	Бібліотеку SoftwareSerial було використано для створення потоків читання і запису на обраних цифрових виходах, що дозволило створення виділених потоків для окремих модулів, таких як ESP8266 WiFi модуль та Ublox NEO-6M GPS модуль.
	Бібліотеку ArduinoUniqueID було використано для ідентифікації IoT пристроя в системі.
	Бібліотеку TinyGPS++ було використано для можливості роботи с даними і потоками GPS.
	Бібліотеку MPU6050 було використано для можливості роботи з потоками і даними акселерометра.
	Бібліотеку ArduinoJSON було використано для можливості шифрування та розшифрування даних у форматі JSON, а також для роботи з ними.
	Бібліотеки ESP8266WiFi та WiFiClientSecure було використано для можливості під’єднання ESP8266 модуля до WiFi та взаємодії з ним.
	Бібліотеку ESP8266HTTPClient було використано для можливості взаємодії з протоколом HTTP на модулі ESP8266. З її допомогою здійснюється відправлення та зчитування запитів з серверної частини.
	Програмна частина пристрою складається з кодової частини для мікроконтролера Arduino Uno та кодової частини для модуля ESP8266 WiFi. Їхнє розподілення обумовлено тим, що зазначені апаратні частини пристрою потребують індивідуального запрограмування для роботи, на відміну від інших модулей, таких як GPS, акселерометр тощо. При цьому, ці кодові частини безпосередньо взаємодіють один з одним за допомогою потоків читання і запису, що дозволяє обмін даними між зазначеними компонентами.
	Розроблено IoT частину за допомогою простої процедурної архітектури з використанням машини станів (State Machine). Основні дії в системі керуються станом, у якому знаходиться автомобіль. Наприклад, під час перебування в стані «у дорозі» система відправляє запит на отримання маршруту до місця призначення та дотримується його при русі. Це дозволяє організувати діяльність системи найпростішим та найбільш близьким до реального світу чином, без великої кількості абстракцій.

2 БУДОВА ПРИСТРОЮ

	Пристрій для IoT частини проєкту складається з мікроконтролера Arduino Uno, модуля ESP8266 WiFi, модуля Ublox NEO-6M, GPS антени, динаміка, акселерометра, і макетної плати (див. рис. 1).
	Усі зазначені частини мають безпосереднє з’єднання з мікроконтролером Arduino Uno та макетною платою. Макетна плата використовується для з’єднання виходів заземлення та навантаження модулів з відповідними виходами мікроконтролера Arduino Uno.
	Виходи для читання (RX) і запису (TX) модуля ESP8266 WiFi мають з’єднання з цифровими виходами D9 та D8 відповідно мікроконтролера Arduino Uno. Зазначені цифрові виходи використовуються для потоків читання і запису для WiFi модуля, що дозволяє надсилання інформації до нього. Також цей модуль має підключення від цифрового виходу D4 до виходу читання (RX) на мікроконтролері Arduino Uno, що дозволяє надсилати інформацію від модуля до мікроконтролера.
	Виходи для читання (RX) і запису (TX) модуля Ublox NEO-6M мають з’єднання з цифровими виходами D11 та D12 відповідно мікроконтролера Arduino Uno. Зазначені цифрові виходи використовуються для потоків читання і запису для GPS модуля, що дозволяє надсилання інформації до нього. Також цей модуль має підключення до GPS антени, що дозволяє отримувати актуальну інформацію про місцеположення з супутників.
	Виходи потоку даних (SDA) і послідовного тактового генератора (SCL) акселерометра мають з’єднання з аналоговими виходами А4 та А5 відповідно мікроконтролера Arduino Uno. Зазначені цифрові виходи використовуються для потоків читання і запису для акселерометра, що дозволяє отримання інформації з нього.
	Вихід динаміка має з’єднання з аналоговим виходом А0 мікроконтролера Arduino. Він дозволяє програвання звуку на динаміку.
	Таким чином, було визначено основні апаратні компоненти IoT частини проєкту.

3 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ
     
     	Користувачами IoT частини розробленої системи є 2 типи акторів: адміністратор та клієнт. 
	Основними потребами клієнта є: можливість можливість відчинення/зачинення дверей автомобіля; можливість здійснення поїздки за заданим маршрутом; можливість зупинки автомобіля під час поїздки; отримання додаткових послуг під час поїздки. 
	Основними потребами адміністратора є: можливість налаштування додаткових послуг для поїздок; отримання інформації про поточний стан автомобіля; сповіщення про загрози для автомобіля; можливість автомобіля автоматично вирушити до найближчої заправної станції у разі низької кількості палива.
	Взаємодію кожної ролі користувачів з IoT частиною системи представлено на діаграмі прецедентів (див. додат. А.1).
	Таким чином, за допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із системою.

4 ПОБУДОВА ДІАГРАМИ ПАКЕТІВ
     
	Для програмування різних частин WiFi модуля ESP8266 були використані бібліотеки ESP8266WiFi, ESP8266HTTPClient, WiFiClientSecure, ArduinoJSON.
	Бібліотеку SoftwareSerial було використано для створення потоків читання і запису на обраних цифрових виходах, що дозволило створення виділених потоків для окремих модулів, таких як ESP8266 WiFi модуль та Ublox NEO-6M GPS модуль.
	Бібліотеку ArduinoUniqueID було використано для ідентифікації IoT пристроя в системі.
	Бібліотеку TinyGPS++ було використано для можливості роботи с даними і потоками GPS.
	Бібліотеку MPU6050 було використано для можливості роботи з потоками і даними акселерометра.
	Бібліотеку ArduinoJSON було використано для можливості шифрування та розшифрування даних у форматі JSON, а також для роботи з ними.
	Бібліотеки ESP8266WiFi та WiFiClientSecure було використано для можливості під’єднання ESP8266 модуля до WiFi та взаємодії з ним.
	Бібліотеку ESP8266HTTPClient було використано для можливості взаємодії з протоколом HTTP на модулі ESP8266. З її допомогою здійснюється відправлення та зчитування запитів з серверної частини.
	Програмна частина пристрою складається з кодової частини для мікроконтролера Arduino Uno та кодової частини для модуля ESP8266 WiFi. Їхнє розподілення обумовлено тим, що зазначені апаратні частини пристрою потребують індивідуального запрограмування для роботи, на відміну від інших модулей, таких як GPS, акселерометр тощо. При цьому, ці кодові частини безпосередньо взаємодіють один з одним за допомогою потоків читання і запису, що дозволяє обмін даними між зазначеними компонентами.

5 ПОБУДОВА ДІАГРАМИ СТАНІВ
     
	Основними станами в системі є «неактивний», «очікує», «у дорозі», «очікує пасажира», «у поїздці» та «обслуговується». Система починає роботу з «неактивного» стану – стан, коли немає живлення у пристрої. При подачі живлення система переходить у стан «очікує». Під час очікування система перевіряє кількість палива автомобіля. Якщо його недостатньо, то відбувається перехід у стан «обслуговується», і автомобіль вирушає до найближчої заправної станції. Після заправлення система повертається до стану очікування. Також відбувається перевірка на те, чи є активна поїздка призначена для цього автомобіля. Якщо така умова виконується, відбувається перехід до стану «у дорозі», під час якого автомобіль вирушає до місця вивезення клієнта. Після того, як автомобіль досягнув місця вивезення, він переходить у стан «очікує пасажира». Коли клієнт розпочинає поїздку, система переходить у стан «у поїздці». Під час поїздки клієнт може зупинити автомобіль, що поверне його у стан «очікує пасажира». Після досягнення місця призначення, система повертається до стану «очікує».
	Для більш детальної візуалізації станів системи було розроблено діаграму станів (див. додат. Б.1).

6 ПОБУДОВА ДІАГРАМИ ВЗАЄМОДІЇ
     
	Взаємодія пристроя з користувачем починається з його увімкнення, потім під’єднання до WiFi і GPS. Далі, коли отримано дані про активну поїздку для цього автомобіля, виконується перевірка кількості палива. При нестачі палива, автомобіль вирушає до найближчої заправної станції. Коли палива достатньо, автомобіль вирушає до місця вивезення клієнта. Після досягнення місця вивезення, автомобіль очікує на клієнта. Коли клієнт розпочав поїздку, пристрій вирушає до місця призначення. Після досягнення місця призначення, коли клієнт завершив поїздку, автомобіль повертається до отримання даних про наступну активну поїздку.
	На основі описаної взаємодії пристрою с користувачем було побудовано діаграму взаємодії (див. рис. 3).

7 ПОБУДОВА ДІАГРАМИ ДІЯЛЬНОСТІ
     
	Діяльність системи можна описати як взаємодію пристроя і серверної частини. Робота пристроя починається з його увімкнення, потім під’єднання до WiFi і GPS. Після під’єднання до GPS, на серверну частину відправляються дані пов’язані з автомобілем (стан, температура, кількість палива, місцеположення). Далі, коли з сервера надходять дані про поїздку, призначену для цього автомобіля, пристрій їх отримує, перевіряє кількість палива. При нестачі палива, пристрій отримує від сервера маршрут до найближчої заправної станції, та вирушає до неї. Коли палива достатньо, автомобіль запитує у сервера маршрут до місця вивезення клієнта та вирушає за ним. Після досягнення місця вивезення, автомобіль очікує на клієнта, постійно отримуючи інформацію про можливе оновлення стану поїздки або дверей автомобіля від клієнта. Коли клієнт розпочав поїздку, пристрій отримує маршрут до місця призначення та вирушає за ним. Після досягнення місця призначення, коли клієнт завершив поїздку, автомобіль повертається до отримання даних про наступну активну поїздку.
	На основі описаної діяльності пристрою було побудовано діаграму діяльності, що відображає взаємодію пристрою з сервером (див. додат. В.1).

ВИСНОВКИ
 
     У ході виконання лабораторної роботи були отримані навички з проєктування IoT частини програмної системи. Результатом роботи є розроблена програмна реалізація IoT частини програмної системи з використанням Arduino. При розробці продукту дотримувались вимоги до чистого коду мови програмування C++.