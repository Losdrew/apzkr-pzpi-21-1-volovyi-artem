Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА 
з навчальної дисципліни «Архітектура програмного забезпечення» 
Тема роботи: Програмна система для мережі таксі автономного керування


Студент гр. ПЗПІ-21-1	_______________ Воловий А.О.
							(підпис)
Керівник роботи	_______________ доц. Лещинський В.О.
							(підпис)

	Робота захищено «_» _____2024р. 
	з оцінкою ____________________
 
Комісія: 	_______________ доц. Лещинський В.О.
							(підпис)													_______________ доц. Лещинська І.О.
							(підпис)
	_______________ ст. викл. Сокорчук І.П.
							(підпис)


Харків
2024 р.
     Харківський національний університет радіоелектроніки

Факультет  комп’ютерних наук		 Кафедра  програмної інженерії		
Спеціальність  121 – Інженерія програмного забезпечення					
Курс 		3             Семестр 					6					
Навчальна дисципліна  Архітектура програмного забезпечення				
     
ЗАВДАННЯ 
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ
 
Воловому Артему Олександровичу

1. Тема роботи: Програмна система для мережі таксі автономного керування «AutoCab»
2. Термін узгодження завдання курсової роботи: «31» березня 2024 р.
3. Термін здачі студентом закінченої роботи: «10» червня 2024 р.
4. Вихідні дані до проєкту (роботи): В програмній системі передбачити: додавання нового клієнта, автомобілів, послуг, створення поїздок, знаходження маршруту, додавання послуг до поїздок. Використовувати ОС Windows 11, СКБД PostgreSQL, середовище розробки Microsoft Visual Studio 2022	 
5. Зміст пояснювальної записки (перелік питань, що належить розробити): вступ,
аналіз предметної області, постановка задачі, проєктування бази даних, архітектура програмної системи, опис програмної системи, висновки, перелік посилань, додатки		
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень):
ER-діаграма бази даних, логічна схема бази даних, діаграма прецедентів серверної частини програмної системи, діаграма розгортання серверної частини програмної системи, діаграма пакетів серверної частини програмної системи, діаграма прецедентів IoT частини програмної системи, будова пристрою IoT частини програмної системи, діаграма пакетів IoT частини програмної системи, діаграма станів IoT частини програмної системи, діаграма взаємодії IoT частини програмної системи, діаграма діяльності IoT частини програмної системи, діаграма прецедентів клієнтської частини програмної системи, діаграма пакетів клієнтської частини програмної системи, діаграма компонентів клієнтської частини програмної системи, діаграма взаємодії клієнтської частини програмної системи, рядок підключення у файлі appsettings.json, головна сторінка сайту, сторінка авторизації, сторінка реєстрації, сторінка входу в систему, сторінка створення поїздки, обрання автомобіля за вказаними адресами, сторінка поїздок користувача, вікно зміни додаткових послуг поїздки, головна сторінка з облікового запису адміністратора, сторінка панелі адміністратора, таблиці користувачів та поїздок, таблиці послуг та автомобілів, перегляд місцеположення автомобіля на карті, результат перевірки на плагіат							

КАЛЕНДАРНИЙ ПЛАН


№Назва етапів курсової роботиТермін виконання етапів роботиПримітки     1Функціональна специфікація програмного проєкту31.03.24     2Проєктування програмного проєкту30.04.24     3Кодування програмного проєкту20.05.24     4Оформлення пояснювальної записки31.05.24     5Захист курсової роботи08.06.24     
	Дата видачі завдання: «25» березня 2024 р.

	Керівник				_______________ доц. Лещинський В.О.
						(підпис)


	Завдання прийняв до виконання
	ст. гр. ПЗПІ-21-1					____________  Воловий А.О.
								(підпис)

     

РЕФЕРАТ


     Пояснювальна записка до курсової роботи: 93 с., 30 рис., 2 табл., 4 додатки, 5 джерел. 
     АВТОНОМНИЙ АВТОМОБІЛЬ, АДМІНІСТРАТОР, КЛІЄНТ, МЕРЕЖА ТАКСІ, МІСЦЕЗНАХОДЖЕННЯ, ПОСЛУГА, ПОЇЗДКА, ПРОГРАМНА СИСТЕМА.
     
     Об’єктом дослідження є індустрія автономних перевезень, а саме актуальне на сьогоднішній день питання щодо організації поїздок за допомогою автономних транспортних засобів з можливістю персоналізації послуг та забезпечення високого рівня безпеки. 
     Метою курсової роботи є розробка системи, яка дозволяє налаштувати роботу мережі таксі, забезпечити автомобілі самостійною навігацією до місця призначення за допомогою побудови маршрутів ґрунтуючись на місцеположенні, створювати поїздки за вказаними адресами, оновлювати додаткові послуги, які може надавати таксі під час поїздки, керувати зупинками автомобіля, здійснювати моніторинг його місцеположення та маршруту у режимі реального часу.
     Методи розробки базуються на технології ASP.NET Core з використанням мови програмування C#, серверу бази даних PostgreSQL, вебзастосунок базується на технології React з мовою програмування TypeScript, розумний пристрій розроблено на платі Arduino Uno, платі ESP8266 WiFi, GPS-модулі Ublox NEO-6M, динаміку та акселерометрі за допомогою Arduino IDE та мови програмування C++.
     У результаті роботи здійснено програмну реалізацію системи для мережі таксі з автономними транспортними засобами. Програмна система складається з вебзастосунку, сервера та розумного пристрою. 

ЗМІСТ


Вступ	8
1 Аналіз предметної області	9
    1.1 Бізнес-вимоги	9
        1.1.1 Бізнес-можливості	9
        1.1.2 Бізнес-цілі та критерії успіху	11
        1.1.3 Потреби клієнтів або ринку	12
        1.1.4 Бізнес-ризики	13
    1.2 Концепція рішення	13
        1.2.1 Окреслення концепції	13
        1.2.2 Головна функціональність	15
        1.2.3 Припущення та залежності	16
    1.3 Рамки та обмеження проєкту	16
        1.3.1 Рамки первинного випуску	16
        1.3.2 Рамки наступних випусків	21
        1.3.3 Обмеження та винятки	22
    1.4 Бізнес-контекст	23
        1.4.1 Профілі зацікавлених сторін	23
        1.4.2 Пріоритети проєкту	24
        1.4.3 Робоче середовище	25
2 Постановка задачі	28
3 Проєктування бази даних	29
    3.1 Побудова ER-діаграми	29
    3.2 Побудова логічної моделі бази даних на основі ER-діаграми	30
4 Архітектура програмної системи	34
    4.1 Архітектура серверної частини	34
    4.2 Архітектура IoT частини	38
    4.3 Архітектура клієнтської частини	46
5 Опис програмної системи	51
    5.1 Виклик і завантаження	51
    5.2 Призначення і логічна структура	52
    5.3 Опис програмної реалізації	53
Висновки	61
Перелік джерел посилання	62
Додаток А Результат перевірки на плагіат	63
Додаток Б Програмний код серверної частини	64
Додаток В Програмний код IoT пристрою	72
Додаток Г Програмний код клієнтської частини	83
     

ВСТУП


     Одним із найважливіших аспектів сучасного життя є мобільність. Люди хочуть мати можливість швидко, безпечно та комфортно пересуватися з одного місця в інше. У цій динамічній реальності традиційні транспортні системи, такі як таксі, стикаються з численними викликами.
     Зростання кількості автомобілів на дорогах призводить до заторів, що збільшує час подорожі та викиди парникових газів. Традиційні таксі часто їздять порожніми, що робить їх неефективними та дорогими. Водії таксі можуть бути втомленими або неуважними, що може призвести до аварій. Таксі можуть бути недоступними в деяких районах або в певний час доби.
     Ще однією проблемою для багатьох користувачів є комунікація з водієм та його поведінка під час поїздки, що може конфліктувати з бажаннями клієнта. Також не виключається фактор непорозуміння на основи мови спілкування під час, наприклад, відряджень або туристичних поїздок. 
     Одночасно з цим, штучний інтелект робить значні кроки вперед. Розробляються нові технології, які дозволяють машинам самостійно керувати транспортними засобами. У цій ситуації автономні транспортні засоби стають перспективним рішенням, що може значно змінити сферу пасажирських перевезень. 
     Автономні таксі, керовані штучним інтелектом, мають потенціал значно знизити рівень забруднення повітря, покращити безпеку дорожнього руху, зробити пересування більш доступним та комфортним для людей з обмеженими можливостями, а також значно економити час та кошти пасажирів.
     Головна мета проєкту полягає у створенні ефективної та автоматизованої системи для надання послуг перевезення клієнтів у мережі таксі. Система спрямована на точне керування мережею автономних таксі, що дозволить покращити якість обслуговування та забезпечити зручність для пасажирів.
     

1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
     1.1 Бізнес-вимоги
     1.1.1 Бізнес-можливості
     
     
     Найбільшими конкурентами у цій галузі автономних перевезень є Waymo, Aurora Technologies та Pony.ai. 
     Waymo самостійно виготовляють автономні машини та надають послуги перевезення клієнтам. Вони мають власну систему контролю автономних автомобілів, та надають користувачам відкритий безкоштовний мобільний застосунок, за допомогою якого можна замовляти поїздки, відстежувати їхній статус та в разі необхідності скасовувати поїздки. Компанія орієнтована тільки на ринок США, що обмежує можливості компанії для глобального розширення. Програмна система, розроблювана Waymo, досить близька до нашої, проте вона пропонує менший функціонал та можливості персоналізації поїздки. Отже, програмна система від Waymo не задовольняє потреби користувачів у зручності використання системи, доступності та персоналізації. 
     Aurora Innovation також самостійно виготовляють автономні машини, проте не надають послуг перевезення. Їхня бізнес-модель зосереджена на співпрацю з іншими бізнесами, які хочуть інтегрувати автомобілі без водія у свої операції. Компанія не надає відкритого мобільного застосунку звичайним користувачам, а лише для внутрішніх потреб бізнесу, з яким співпрацює. Aurora Innovation орієнтовані на ринок США, що обмежує можливості глобального розширення. Система, розроблювана компанією, орієнтована на потреби бізнесу, а не звичайних користувачів. Отже, програмна система від Aurora Technologies не задовольняє потреби користувачів у безпеці перевезення, зручності використання системи, доступності та персоналізації. 
     Pony.ai також самостійно виготовляють автономні машини та надають послуги перевезення клієнтам. Вони, як і Waymo, мають власну систему контролю автономних автомобілів, та надають користувачам відкритий безкоштовний мобільний застосунок, проте він доступний тільки у межах Китаю, оскільки компанія орієнтована саме китайський ринок. Це обмежує можливості компанії для глобального розширення. Програмна система, розроблювана Pony.ai, близька до нашої, проте вона пропонує менший функціонал та можливості персоналізації поїздки. Отже, програмна система від Pony.ai не задовольняє потреби користувачів у зручності використання системи, доступності та персоналізації. 
     Зважаючи на системи конкурентів, можна виділити відмінності та переваги нашого проєкту: 
− проєкт орієнтований на глобальний ринок; 
− доступність автомобілів у будь-який день та час доби; 
− можливість обрати найбільш задовільний автомобіль з доступних за власними вподобаннями (кількість сидінь, розмір тощо);
− більшість конкурентів орієнтовані на ринок США, але наша система надаватиме послуги по всьому світу; 
− користувачі зможуть здійснювати замовлення та моніторинг поїздки у реальному часі за допомогою відкритого мобільного застосунку; 
− великі можливості персоналізації поїздки. 
     Наша модель монетизації передбачає отримання прибутку завдяки наданню послуги перевезень клієнтам з динамічним ціноутворенням, що залежатиме від дистанції поїздки та попиту. Плата стягуватиметься за кожну поїздку клієнта.
     Клієнтами нашої програмної системи є люди, які потребують швидкого та безпечного перевезення з мінімальним ризиком аварій та без турбування з боку водія. Програмна система орієнтуватиметься на перевезення як у містах, так і за їхніми межами. Типовим клієнтом нашої системи є молода людина років 18-35, якій необхідно дістатися на роботу, додому або на відпочинок. Такому клієнту найбільш зручно буде викликати таксі за допомогою мобільного застосунку, у ньому отримувати всю необхідну інформацію про поїздку та маршрут, а також скористатися можливостями персоналізації. 
     Цільовими ринками розроблюваної системи є: 
− міста з високою щільністю населення; 
− міста з проблемами заторів; 
− міста з проблемами забруднення повітря. 
     Підходами до маркетингу розроблюваної системи є: 
− поширення інформації про систему через цифрові канали, такі як вебсайти, соціальні мережі та пошукова реклама, щоб охопити нашу цільову аудиторію; 
− співпраця з виробниками автомобілів, транспортними компаніями та міськими владами, щоб просувати наш продукт; 
− участь у громадських заходах для підвищення обізнаності про наш продукт. 
Стратегіями просування розроблюваної системи є: 
− безкоштовні пробні версії, щоб отримати початкові відгуки користувачів;
− програми лояльності, щоб заохочувати клієнтів до повторного використання нашого продукту; 
− інформування користувачів про можливості персоналізації.
     
     
     1.1.2 Бізнес-цілі та критерії успіху
     
     
     БЦ-1: Зменшити витрати на обслуговування перевезень: Досягти зниження витрат на обслуговування перевезень на 30% протягом перших двох років використання програмного продукту.
     БЦ-2: Розширити ринкову присутність: Охопити не менше трьох нових регіонів з протягом першого року впровадження продукту.
     БЦ-3: Підвищити ефективність перевезень: Забезпечити покращення ефективності перевезень на 25% у порівнянні з традиційними методами перевезень протягом першого року експлуатації.
     КУ-1: Кількість партнерств: Укласти партнерські угоди з не менше ніж трьома компаніями до кінця першого року роботи продукту.
     КУ-2: Кількість користувачів та платників послуг: Досягти реєстрації не менше ніж 500 тисяч активних користувачів та забезпечити мінімум 50% від них як платників послуг протягом першого року використання.
     КУ-3: Приріст прибутку: Забезпечити приріст прибутку компанії на 40% від попереднього фінансового року протягом перших двох років впровадження продукту.
     КУ-4: Розширення функціонала: Запровадити не менше трьох нових функцій в системі протягом першого року використання продукту.
     
     
     1.1.3 Потреби клієнтів або ринку
     
     
     Потреби клієнтів: 
− швидкість перевезення: клієнти очікують, що транспортні засоби будуть швидко та ефективно доставляти їх до місця призначення, мінімізуючи час на дорогу та затримки, що дозволяє їм планувати свої поїздки з більшою впевненістю.
− безпека та надійність перевезення: клієнти вимагають високого рівня безпеки під час поїздки, включаючи захист від аварій, постійний моніторинг стану автомобіля та водія, а також наявність механізмів швидкого реагування на надзвичайні ситуації. Надійність перевезення передбачає мінімізацію ризику збоїв та забезпечення стабільної роботи системи у будь-яких умовах.
− зручний інтерфейс для моніторингу та сповіщення про статус перевезення: клієнти потребують інтуїтивно зрозумілого та зручного інтерфейсу, який дозволяє легко стежити за статусом поїздки в реальному часі, отримувати своєчасні сповіщення про зміни маршруту, очікуваний час прибуття, а також інші важливі оновлення. Інтерфейс повинен бути доступний як на мобільних пристроях, так і на вебплатформах, забезпечуючи зручний доступ до інформації незалежно від місця перебування клієнта.
     
     
     1.1.4 Бізнес-ризики
     
     
     Ризики:
− конкуренція на ринку автоматизованих перевезень невелика, проте наявні досить розвинені великі компанії; 
− низький попит або недостатній інтерес з боку цільової аудиторії; 
− труднощі під час впровадження або невдале впровадження системи у партнерських компаніях. 
     Можливі дії: 
− вдосконалення маркетингових стратегій; 
− співпраця з ключовими гравцями ринку; 
− проведення пілотних запусків та тестувань перед повним впровадженням; 
− надання навчання та підтримки новим користувачам


     1.2 Концепція рішення
     1.2.1 Окреслення концепції
     
     
     Головна ідея проєкту полягає у створенні ефективної та автоматизованої системи для надання послуг перевезення клієнтів у мережі таксі. Система спрямована на точне керування мережею автономних таксі, що дозволить покращити якість обслуговування та забезпечити зручність для пасажирів. 
     Продукт надасть можливість клієнтам легко та зручно замовляти таксі через мобільний застосунок або вебсайт, а адміністраторам – зручно налаштовувати та обслуговувати екосистему автомобілів через виділену панель адміністратора. Головна мета полягає у забезпеченні безпеки та комфорту під час поїздки, а також у вчасному та ефективному наданні послуг. 
     Головною особливістю IoT частини проєкту є інтеграція спеціальних пристроїв у кожен транспортний засіб мережі таксі. Ці пристрої обладнані датчиками та модулями зв'язку, які забезпечують збір та передачу важливих даних на серверну частину системи. Основні функції IoT пристроїв включають: автономне керування транспортом, збір та відправлення даних про стан транспорту, обмін даними про маршрут та місцезнаходження. 
     Основні переваги проєкту включають надання найбільш комфортної послуги перевезення та забезпечення безпеки під час поїздки, що допоможе забезпечити задоволення клієнтів та підвищити рівень довіри до системи. Використання штучного інтелекту та автономного керування також дозволить зменшити ризики дорожніх пригод та забезпечити безпеку під час поїздки. 
     Оскільки однією з головних переваг системи є безпека, необхідно забезпечити високу безпеку даних користувачів. Всі дані, що передаються між клієнтською частиною (мобільний застосунок або вебсайт), IoT пристроями та серверною частиною системи, шифруються з використанням надійних протоколів шифрування. Для забезпечення доступу лише авторизованим користувачам до конфіденційної інформації використовуються механізми автентифікації та авторизації. Кожен користувач має свої унікальні облікові дані, і доступ до різних функціональних можливостей системи обмежується відповідно до їхніх ролей та прав доступу. Система постійно спостерігає за активністю користувачів та обміном даними, щоб виявляти будь-які підозрілі або неавторизовані дії. Звіти подій зберігаються та аналізуються для виявлення потенційних загроз безпеці даних. 
     Впровадження програмної системи буде сприяти підвищенню ефективності та конкурентоспроможності бізнесу, а також забезпечить покращення якості обслуговування для клієнтів. Це стане важливим кроком у розвитку та оновленню транспортної індустрії, що відкриє нові можливості для підприємств і покращить їхнє ставлення на ринку перевезень.
     
     
     1.2.2 Головна функціональність
     
     
     ГФ-1: Створення замовлень: Користувачі можуть створювати замовлення на бажаний маршрут (заданий місцем відправлення та місцем прибуття) для обраного автомобіля. 
     ГФ-2: Персоналізація поїздки: Користувачі можуть задати спеціальні умови поїздки, такі як: наявність голосового асистента, програвання музики, температура в салоні, місця зупинки по дорозі. 
     ГФ-3: Моніторинг статусу та місцеположення автомобілів у реальному часі: Користувачі можуть в реальному часі спостерігати за місцезнаходженням та статусом автомобілів, що здійснюють перевезення. 
     ГФ-4: Керування автомобілем: Користувачі можуть керувати відкриттям та закриттям дверей в автомобілі, початком або завершенням маршруту, зупинками під час поїздки.
     ГФ-5: Можливість дистанційного керування системою через мобільний застосунок або вебсайт: Користувачі можуть керувати системою та автомобілями з використанням мобільного застосунку або вебінтерфейсу. 
     ГФ-6: Повідомлення користувачів про прибуття автомобіля, кількість пального, аварійні ситуації та закінчення поїздки: Система надсилає оповіщення користувачам на мобільний застосунок та вебсайт щодо статусу поїздки та можливих проблем з автомобілем. 
     ГФ-7: Технічна підтримка користувачів для вирішення технічних питань та надання порад щодо використання системи: Користувачі зможуть отримати технічну підтримку у мобільного застосунку або на вебсайті для вирішення проблем з системою. 
     ГФ-8: Багатомовний інтерфейс: Користувачі можуть користуватися застосунком англійською й українською мовами.
     
     
     1.2.3 Припущення та залежності
     
     
     П-1: Клієнти готові сплачувати за перевезення. 
     П-2: Автономний автомобіль, у який буде встановлено мікросхему системи, є сумісним. 
     П-3: Наявне стійке Інтернет-з'єднання для забезпечення обміну даними з автомобілями та користувачами. 
     З-1: Наявність та працездатність автомобілів автономного керування. 
     З-2: Наявність штучного інтелекту який може здійснювати керування автомобілем.
     
     
     1.3 Рамки та обмеження проєкту
     1.3.1 Рамки первинного випуску
     
     
Серверна частина повинна включати: 
− реєстрацію та авторизацію користувачів: реалізація системи користувачів та механізмів входу з підтримкою ролей та прав доступу; 
− створення, редагування, перегляд автономних автомобілів: можливість внесення, редагування та перегляду інформації про автомобіль; 
− створення, перегляд, оновлення, скасування поїздок: можливість внесення, оновлення, перегляду інформації про поїздки, а також їх скасування; 
− керування поїздкою: можливість вибору спеціальних умови поїздки, такі як: наявність голосового асистента, програвання музики, температура в салоні, місця зупинки по дорозі; 
− автоматична побудова маршруту поїздки: маршрут поїздки буде будуватися автоматично з використанням сервісів GPS-навігації; 
− моніторинг автомобілів: збір та повернення інформації про статус та місцезнаходження автомобілів у реальному часі; 
− сповіщення користувачів: відправлення сповіщень користувачам про прибуття автомобіля, кількість пального, аварійні ситуації та закінчення поїздки; 
− керування автомобілем: керування відкриттям та закриттям дверей в автомобілі, початком або завершенням маршруту, зупинками під час поїздки;
− адміністрування системи: управління користувачами системи, управління даними системи, створення резервних копій налаштувань та даних, експорт та імпорт даних та налаштувань, управління сертифікатами; 
− захист від атак: використання сучасних методів захисту, такі як параметризовані запити SQL та валідація введених даних, для запобігання атакам SQL-ін'єкції та іншим формам вразливостей; 
− шифрування даних: збереження конфіденційних даних, у зашифрованому вигляді, з використанням сучасних алгоритмів шифрування, таких як SHA256; 
− механізми резервного копіювання та відновлення даних: наявність автоматизованих механізмів резервного копіювання, які регулярно зберігатимуть копії даних. У випадку аварійної ситуації, буде забезпечений швидкий відновлювальний процес з використанням збережених резервних копій; 
− механізми синхронізації даних: використання стратегій обробки конфліктів даних, такі як "останній переможець" або "об'єднання", щоб уникнути втрати чи відтворення невідповідностей. 
IoT частина повинна включати: 
− визначення маршруту: автомобіль отримуватиме місцезнаходження точки прибуття та маршрут до неї завдяки запиту до серверної частини; 
− збір і відправлення даних: оновлення даних автомобілів (статус, місцезнаходження, переміщення, кількість палива) та їх відправлення на серверну частину; 
− програвання сигналів та аудіозаписів: звукові та світлові сигнали для привернення уваги користувачів, програвання аудіозаписів у салоні, голосовий асистент; 
− реагування та повідомлення про загрози: сигналізація при спробі примусового проникнення в автомобіль та відправлення інформації про це на серверну частину; 
− визначення місцезнаходження заправної станції: автомобіль отримуватиме найближче місцезнаходження заправної станції при низькій кількості палива, щоб вчасно поповнити запас; 
− захист від вторгнень: захист від потенційних вторгнень за допомогою механізмів автентифікації та авторизації. Будуть використані сучасні методи шифрування, такі як SHA256, та обмеження доступу до системних ресурсів для запобігання несанкціонованому доступу до пристроїв; 
− захист конфіденційності даних: всі дані, які збираються та відправляються IoT пристроями, будуть шифровані за допомогою методу шифрування TLS перед передачею на серверну частину. 
Front-end частина повинна включати: 
− реєстрація та вхід користувачів: наявність механізмів для автентифікації та авторизації користувачів перед наданням доступу до функцій системи. Використовуватимуться безпечні методи аутентифікації, такі як JWT (JSON Web Token), для забезпечення безпеки процесу входу; 
− створення, редагування, перегляд автомобілів: можливість внесення, редагування та перегляду інформації про автономні автомобілі; 
− створення, перегляд, оновлення, скасування поїздок: можливість внесення, оновлення, перегляду інформації про поїздки, а також їх скасування; 
− керування поїздкою: можливість вибору спеціальних умови поїздки, такі як: наявність голосового асистента, програвання музики, температура в салоні, місця зупинки по дорозі; 
− панель адміністратора: панель, що дозволяє управління користувачами системи, управління даними системи, створення резервних копій налаштувань та даних, експорт та імпорт даних та налаштувань, управління сертифікатами; 
− локалізований та інтернаціоналізований інтерфейс: підтримка української та англійської мови, використання інтернаціональних кодових таблиць символів, локалізоване обчислення та формат дати та часу, підтримка локального та універсального часу, метричних одиниць вимірювання, англійських та американських систем мір, порядку сортування текстових значень, різного напряму введення тексту; 
− сповіщення користувачів: відправлення сповіщень користувачам про прибуття автомобіля, кількість пального, аварійні ситуації та закінчення поїздки; 
− захист від XSS (Cross-Site Scripting) та CSRF (Cross-Site Request Forgery) атак: використання механізмів вбудованого захисту від XSS та CSRF атак для запобігання вразливостям, пов'язаним з введенням користувача; 
− використання HTTPS протоколу: всі з'єднання між клієнтом та сервером будуть здійснюватися через HTTPS протокол для забезпечення шифрування даних під час передачі через мережу; 
− валідація введених даних: використання механізмів валідації для перевірки введених користувачем даних перед їх відправленням на сервер, що допоможе уникнути вразливостей і некоректних операцій; 
− моніторинг безпеки та реагування на загрози: буде реалізована система моніторингу захисту, яка виявлятиме та реагуватиме на можливі загрози безпеці. Це включатиме в себе виявлення надзвичайних подій, аналіз журналів подій та автоматичне сповіщення адміністраторів про потенційні атаки або вразливості. 
Мобільна частина повинна включати: 
− реєстрація та вхід користувачів: наявність механізмів для автентифікації та авторизації користувачів перед наданням доступу до функцій системи. Використовуватимуться безпечні методи аутентифікації, такі як JWT (JSON Web Token), для забезпечення безпеки процесу входу; 
− створення, редагування, перегляд автомобілів: можливість внесення, редагування та перегляду інформації про автономні автомобілі; 
− створення, перегляд, оновлення, скасування поїздок: можливість внесення, оновлення, перегляду інформації про поїздки, а також їх скасування; 
− керування поїздкою: можливість вибору спеціальних умови поїздки, такі як: наявність голосового асистента, програвання музики, температура в салоні, місця зупинки по дорозі; 
− перегляд поїздки: перегляд інформації про конкретну поїздку та автомобіль, який її обслуговує; 
− керування автомобілем: керування відкриттям та закриттям дверей в автомобілі, початком або завершенням маршруту, зупинками під час поїздки; 
− сповіщення користувачів: відправлення сповіщень користувачам про прибуття автомобіля, кількість пального, аварійні ситуації та закінчення поїздки; 
− локалізований та інтернаціоналізований інтерфейс: підтримка української та англійської мови, використання інтернаціональних кодових таблиць символів, локалізоване обчислення та формат дати та часу, підтримка локального та універсального часу, метричних одиниць вимірювання, англійських та американських систем мір, порядку сортування текстових значень, різного напряму введення тексту; 
− шифрування даних: усі дані, що передаються через мобільний застосунок, будуть шифруватися з використанням надійних алгоритмів шифрування, таких як TLS, для запобігання витоку конфіденційної інформації під час передачі через мережу; 
− захист від несанкціонованого доступу: в мобільному застосунку будуть використовуватися механізми безпеки, такі як токени доступу та механізми перевірки доступу, для запобігання несанкціонованому доступу до особистої інформації користувачів та інших конфіденційних даних; 
− моніторинг та збереження подій: мобільний застосунок буде відстежувати та зберігати події, пов'язані із взаємодією користувачів із системою, для виявлення та реагування на будь-які можливі загрози безпеці; 
− захист від витоку даних: мобільний застосунок буде використовувати механізми захисту від витоку даних, такі як використання безпечного збереження та обробки конфіденційних даних на пристрої користувача, щоб запобігти несанкціонованому доступу до особистої інформації.


     1.3.2 Рамки наступних випусків


Серверна частина може включати: 
− відгуки про сервіс: можливість користувачам залишати відгуки про наш сервіс; 
− аналітика та статистика: аналітика поїздок та переміщення автомобілів, надання звітів про роботу для користувачів та адміністраторів, відстеження продуктивності та ефективності поїздок. 
IoT частина може включати: 
− переміщення завдяки штучному інтелекту: можливість автомобіля самостійно переміщуватися за заданим маршрутом, аналізуючи ситуацію на дорозі та оминаючи перешкоди; 
− розширена система збереження палива: реалізація розумної системи керування паливом автомобілів. 
Front-end частина може включати: 
− карта моніторингу автомобілів: відображення місцезнаходження автомобілів на мапі у режимі реального часу; 
− перегляд аналітики та статистики: можливість перегляду аналітики поїздок та переміщення автомобілів, отримання звітів про роботу для користувачів та адміністраторів; 
− відгуки про сервіс: можливість користувачам залишати відгуки про наш сервіс; 
− пошук і фільтрація доступних автомобілів: реалізація пошуку та фільтрації доступних автомобілів за різними критеріями; 
− підтримка платіжних систем: можливість оплати поїздки безпосередньо через застосунок. 
Мобільна частина може включати: 
− геолокація та маршрутизація: можливість визначення місцезнаходження користувача та автоматичного визначення найближчих автомобілів для поїздки; 
− підтримка платіжних систем: можливість оплати поїздки безпосередньо через застосунок.
     
     
     1.3.3 Обмеження та винятки
     
     
− залежність від кількості палива автомобіля: оскільки головною частиною нашого продукту є автомобілі, функціональність системи залежна від їхньої працездатності; 
− залежність від технічних можливостей автономних автомобілів: використання автономних автомобілів обмежене їхніми технічними можливостями, включаючи швидкість, максимальну кількість місць та пройдену відстань без заправлення; 
− підключення до мережі Інтернет: для забезпечення зв’язку з системою необхідне підключення до мережі Інтернет. При його відсутності можливе обмеження функціональних можливостей керування й моніторингу; 
− непередбачувані умови на маршруті: непередбачені умови дороги або маршруту можуть спричинити винятки в розрахунках шляху та часу перевезення, вимагаючи адаптації системи.
     
     
     1.4 Бізнес-контекст
     1.4.1 Профілі зацікавлених сторін
     
     
     Профілі зацікавлених сторін проекту наведені в таблиці 1.1.
     
     Таблиця 1.1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторонаГоловна цінністьСтавленняГоловний інтересОбмеження     Звичайні користувачіЛегкість і зручність користування системою, можливість отримування усієї необхідної інформації про перевезення та автомобілі у режимі реального часуЗацікавленість, проте можливе покинення застосунку у зв’язку з незадоволеними очікуваннямиІдея автономного таксі, простота використання системиДоступ до мережі Інтернет          
     Кінець табл. 1.1
Зацікавлена сторонаГоловна цінністьСтавленняГоловний інтересОбмеження     Розробник проєктуМожливість гарно заробити та в подальшому розширити компаніюЗацікавленість в успіху проєкту та задоволенні цільової аудиторіїЗаробіток, репутаціяПравові обмеження, нестача досвіду, грошові обмеження, доступ до мережі Інтернет     ІнвесториОтримання прибуткуЗацікавленість в успіху проєкту та отриманні великого прибутку від його кінцевої реалізаціїЗаробітокГрошові обмеження          
     
     1.4.2 Пріоритети проєкту
     
     
     Пріоритети проєкту наведені в таблиці 1.2.
     
     Таблиця 1.2 – Пріоритети проєкту
ПоказникВиконання (етапи)Обмеження (граничні значення)Ступінь свободи (допустимий діапазон)     План робітпродукт має бути випущеним до 10.06.2024можливе відхилення від графіку на 1-2 місяці     Функціональність90% функціоналу має працювати на випуску 1.0     Якістьу випуску 1.0 повинні пройти 100% тестувань     	Кінець табл. 1.2
ПоказникВиконання (етапи)Обмеження (граничні значення)Ступінь свободи (допустимий діапазон)     Персоналмаксимальний розмір команди – один розробник та адміністратор     Ціна100000 гривеньдопустиме відхилення на 15%     	
     
     1.4.3 Робоче середовище
     
     
     Система має обслуговувати користувачів з різних країн, тому надійність, безпека та доступність є ключовими аспектами робочого середовища. Для досягнення цих цілей, ми обираємо хмарні сервіси Microsoft Azure для забезпечення безперервного доступу до системи. Azure надає високу доступність, резервне копіювання даних та захист від збоїв. 
     Для забезпечення безпеки даних ми обираємо PostgreSQL як систему управління базами даних, оскільки вона відповідає вимогам GDPR із захисту даних користувачів і надає різноманітні механізми захисту, такі як ролева автентифікація та шифрування даних [1]. Доступ до них буде здійснюватися за допомогою бібліотеки Entity Framework Core, що забезпечує високий рівень захисту та швидкість роботи. 
     Управління ризиками використання обраних програмних засобів включає оцінку потенційних загроз для безпеки даних та швидкості відповіді сервера. Наприклад, ми можемо виявити ризики зв'язані з можливими атаками на сервер, і розробити план заходів для їх уникнення або зменшення наслідків. 
     Також важливо розширити доступність застосунку завдяки локалізації (українська та англійська мови) та інтернаціоналізації (міри ваги, довжини тощо). Оскільки застосунок працюватиме в різних країнах, важливо врахувати різницю в часових поясах та представленні часу. 
     Для розробки серверної частини буде використано технологію ASP.NET Core, що використовує мову програмування C#. Середовищем розробки буде Visual Studio. ASP.NET Core забезпечує надійність шляхом використання вбудованих механізмів перевірки даних, обробки винятків та механізмів відновлення після збоїв. Технологія володіє вбудованим механізмом керування станом, який дозволяє зберігати стан застосунку навіть після перезапуску сервера або збоїв програмного забезпечення. Крім того, ASP.NET Core надійно працює з базами даних, такими як PostgreSQL, і забезпечує високу ефективність та швидкодію за рахунок оптимізації запитів та кешування даних. 
     Щодо доступності, ASP.NET використовує механізми масштабування та балансування навантаження, що дозволяють розподілити трафік між різними серверами та забезпечити безперервну доступність навіть у разі збоїв окремих компонентів. Крім того, можливість розгортання ASP.NET Core застосунків у хмарних сервісах, таких як Microsoft Azure, дозволяє забезпечити високу доступність за рахунок географічно розподілених центрів обробки даних та автоматичного масштабування ресурсів [2]. 
     Для розробки IoT частини буде використовуватися Arduino. Середовищем розробки буде Arduino IDE, мовою програмування C++. Також на Arduino буде встановлено ультразвуковий датчик відстані, динамік, GPS та Wi-Fi модулі. Встановлені модулі забезпечать точне визначення місцезнаходження та бездротовий зв'язок з сервером. Ультразвуковий датчик відстані та динамік допоможуть у виявленні перешкод та наданні звукових сигналів під час руху транспорту, що покращить безпеку та надійність IoT частини системи. Також буде забезпечено безпеку зберігання та передачі даних за допомогою шифрування та автентифікації. Механізми захисту також включають контроль доступу до пристроїв та захист від несанкціонованого доступу. 
     Для розробки вебзастосунку буде використано фреймворк React.js, що використовує мову JavaScript. Середовищем розробки буде Visual Studio. Для вирішення проблем з безпекою та захистом від XSS атак під час використання фреймворку React.js, в нашій системі буде використано низку запобіжних заходів. Зокрема, будемо використовувати вбудовані можливості React для безпечної вставки даних у вебсторінки через механізми, такі як JSX (JavaScript XML) або безпечне відображення тексту через використання вбудованих методів React для очищення вхідних даних від потенційно небезпечних скриптів [3]. 
     Щодо можливих труднощів у використанні React.js для розробки асинхронних функцій, які можуть бути потрібні для взаємодії з сервером, в нашій системі ми плануємо використовувати сучасні підходи та бібліотеки для керування асинхронними запитами. Наприклад, для роботи з асинхронним кодом та виконання запитів до сервера будемо використовувати бібліотеку Axios та вбудовані можливості JavaScript, такі як асинхронні функції та ключові слова async/await, які дозволяють зручно та ефективно працювати з асинхронним кодом в React.js застосунках. Такий підхід дозволить нам забезпечити ефективну та безпечну взаємодію з сервером у нашій системі. 
     Для розробки мобільної частини буде використано технологію MAUI, що використовує мову програмування C#. Середовищем розробки буде Visual Studio. У контексті вимог до швидкості відповіді сервера та надійності, фреймворк MAUI та мова програмування C# виявляються досить ефективними і надійними виборами. MAUI розширює можливості розробки мобільних застосунків, дозволяючи створювати єдиний код, який може запускатися на різних платформах, забезпечуючи одноманітність і стабільність застосунків. 
     Використання мови програмування C# також сприяє швидкодії та надійності застосунків. C# має вбудовану підтримку асинхронного програмування, що дозволяє ефективно працювати з асинхронними операціями, такими як мережеві запити до сервера, без блокування основного потоку виконання, тим самим забезпечуючи швидкість відповіді застосунку. 
     

2 ПОСТАНОВКА ЗАДАЧІ
     
     
     За результатами попереднього аналізу предметної області, задачею курсової роботи було поставлено створення програмної системи для мережі таксі автономного керування.
     База даних повинна включати інформацію про: користувачів, ролі, поїздки, адреси, автомобілі, послуги, послуги у поїздці.
     Для клієнта має бути реалізований такий функціонал:
* реєстрація та вхід в систему;
* перегляд доступних автомобілів для поїздки за вказаними адресами;
* створення поїздки;
* перегляд власних поїздок;
* перегляд інформації про обрану поїздку;
* можливість скасування поїздки;
* можливість оновлення додаткових послуг для обраної поїздки.
     Для адміністратора системи має бути реалізований такий функціонал:
* реєстрація та вхід в систему;
* керування користувачами системи;
* перегляд, додавання, редагування, видалення автомобілів;
* перегляд місцезнаходження автомобіля на карті;
* перегляд, додавання редагування, видалення додаткових послуг;
* експорт та імпорт даних системи;
* експорт та імпорт сертифікатів системи.
     Також програмна система повинна підтримувати локалізацію та інтернаціоналізацію, а саме, забезпечувати: підтримку різних кодових таблиць символів, обчислення та формат дати та часу, локальний та універсальний час, метричні одиниці вимірювання, англійську та американську систему мір, порядок сортування текстових значень, різні напрями введення тексту тощо.

3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
     3.1 Побудова ER-діаграми
     
     
     На підставі аналізу предметної області, було визначено основні сутності та встановлено зв’язки між ними. Їх було представлено у вигляді ER-діаграми (див. рис. 3.1).


Рисунок 3.1 – ER-діаграма бази даних

     Сутність Користувачі – це сутність, яка містить інформацію про користувачів системи, і пов’язана зв’язком «один-до-багатьох» із сутністю Поїздки.
     Сутність Ролі – це сутність, що містить інформацію про ролі, які можуть мати користувачі, і пов’язана зв’язком «один-до-багатьох» із сутністю Користувачі.
     Сутність Адреси – це сутність, що містить інформацію про адреси, які використовувались для поїздок, і пов’язана зв’язком «один-до-багатьох» із сутністю Поїздки.
     Сутність Поїздки – це сутність, що містить інформацію про поїздки клієнтів, і пов’язана із сутностями Користувачі, Адреси, Автомобілі зв’язком «один-до-багатьох» та із сутністю Послуги зв’язком «багато-до-багатьох».
     Сутність Автомобілі – це сутність, що містить інформацію про автономні автомобілі мережі таксі, і пов’язана із сутністю Автомобілі зв’язком «один-до-багатьох».
     Сутність Послуги – це сутність, що містить інформацію про додаткові послуги для поїздки, які надає мережа таксі, і пов’язана із сутністю Поїздки зв’язком «багато-до-багатьох».
     
     
     3.2 Побудова логічної моделі бази даних на основі ER-діаграми
     
     
     Для забезпечення нормалізації бази даних, варто позбутися зв’язку «багато-до-багатьох» між сутностями Поїздки та Послуги. Для цього створимо проміжну сутність Послуги_Поїздки.
     Отже, у логічній моделі бази даних будуть представлені такі сутності:
* користувачі (Users);
* ролі (Roles);
* поїздки (Trips);
* адреси (Addresses);
* автомобілі (Cars);
* послуги (Services);
* послуги_поїздки (TripServices).
     Створимо таблицю користувачів (Users). Вона буде містити у собі такі атрибути: user_id (первинний ключ), email, password, first_name, last_name, phone_number, role_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Roles). 
     Перевіримо таблицю Users на відповідність нормалізації:
* усі атрибути атомарні: містять лише одне значення, а не множину;
* відсутність повторюваності даних;
* усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю карток ролей (Roles). Вона буде містити у собі такі атрибути: role_id (первинний ключ), name.
     Перевіримо таблицю Roles на відповідність нормалізації:
* усі атрибути атомарні: містять лише одне значення, а не множину;
* відсутність повторюваності даних;
* усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю поїздок (Trips). Вона буде містити у собі такі атрибути: trip_id (первинний ключ), start_address_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Adresses), destination_address_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Adresses), start_datetime, end_datetime, status, price, user_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Users), car_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Cars).
     Перевіримо таблицю Trips на відповідність нормалізації:
* усі атрибути атомарні: містять лише одне значення, а не множину;
* відсутність повторюваності даних;
* усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю адрес (Addresses). Вона буде містити у собі такі атрибути: address_id (первинний ключ), address_line_1, address_line_2, address_line_3, address_line_4, town_city, region, country.
     Перевіримо таблицю Addresses на відповідність нормалізації:
* усі атрибути атомарні: містять лише одне значення, а не множину;
* відсутність повторюваності даних;
* усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю автомобілів (Cars). Вона буде містити у собі такі атрибути: car_id (первинний ключ), brand, model, licence_plate, status, passenger_seats_num, location, temperature, fuel, device_id.
     Перевіримо таблицю Cars на відповідність нормалізації:
* усі атрибути атомарні: містять лише одне значення, а не множину;
* відсутність повторюваності даних;
* усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю послуг (Services). Вона буде містити у собі такі атрибути: service_id (первинний ключ), name, command. 
     Перевіримо таблицю Services на відповідність нормалізації:
* усі атрибути атомарні: містять лише одне значення, а не множину;
* відсутність повторюваності даних;
* усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю послуг в поїздках (TripServices). Вона буде містити у собі такі атрибути: trip_service_id (первинний ключ), trip_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Trips), service_id (зовнішній ключ для зв’язку «один-до-багатьох» з таблицею Services). 
     Перевіримо таблицю на відповідність нормалізації:
* усі атрибути атомарні: містять лише одне значення, а не множину;
* відсутність повторюваності даних;
* усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     За результатами проектування таблиць та зв’язків майбутньої бази даних, отримано її логічну схему (див. рис. 3.2).


Рисунок 3.2 – Логічна схема бази даних

     Оскільки всі таблиці в наведеній логічній схемі бази даних знаходяться в третій нормальній формі, то можна зробити висновок, що отримана база даних знаходиться в третій нормальній формі.
     

4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
     4.1 Архітектура серверної частини
     
     
     Користувачами серверної частини є 2 типи акторів: клієнт та адміністратор. 
     Основними потребами клієнта є: можливість перегляду доступних автомобілів, які можуть здійснити поїздку за вказаними початковою та кінцевою адресою: можливість замовлення поїздки на обраному автомобілі; можливість перегляду інформації про власні поїздки; можливість отримання додаткових послуг під час поїздки; можливість безпечно дістатися до місця призначення. 
     Основними потребами адміністратора є: можливість перегляду та керування користувачами системи; можливість створення, редагування, видалення автономних автомобілів в системі; можливість налаштування автономних автомобілів в системі; можливість створення, редагування, видалення додаткових послуг для поїздок; можливість створення резервних копій даних системи та їхній імпорт в систему. 
     Взаємодію користувачів з серверною частиною системи представлено на діаграмі прецедентів (див. рис. 4.1).


Рисунок 4.1 – Діаграма прецедентів серверної частини програмної системи
     
     Для написання серверної частини системи було обрано мову програмування C# з використанням технології ASP.NET Core Web API, яка забезпечує швидку розробку, високу продуктивність та надійність. 
     У якості бази даних використано PostgreSQL, до якої з серверного застосунка здійснюється доступ за допомогою технології Entity Framework Core, що надає зручний інтерфейс для взаємодії з базами даних у вигляді об’єктів сутностей. 
     Для більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.2).
     

Рисунок 4.2 – Діаграма розгортання серверної частини програмної системи
     
     Для демонстрації та тестування API використовується OpenApi (Swagger), що дозволяє зручно тестувати та документувати API, покращуючи якість та зручність розробки. 
     Для забезпечення безпеки даних та конфіденційності використовується захищений протокол HTTPS, що захищає дані під час їхньої передачі. 
     Для автоматизації процесу мапування між об’єктами використано бібліотеку AutoMapper. Це дозволяє зменшити кількість одноманітного коду при роботі з об'єктами даних та спрощує розробку серверної частини. 
     Для реалізації автентифікації та авторизації використано бібліотеку .NET Identity, що дозволяє що забезпечує гнучкий та потужний механізм для управління користувачами та їхнім доступом до різних частин системи. 
     Для маршрутизації запитів використанні API контролери, що є вбудованими засобами розробки на ASP .NET Core. Вони дозволяють розділити програму на логічні компоненти, кожен з яких відповідає за обробку конкретного виду запитів або дій користувача. Це спрощує керування кодом та його розширення. 
     Розроблений серверний застосунок побудований за принципами Clean Architecture та складається з декількох шарів: Presentation рівень, Application рівень, Domain рівень та Infrastructure рівень. Кожний вищий шар залежить від нижчого. 
     У якості способу організації коду було обрано CQRS (Command Query Responsibility Segregation), який розділяє команди, які змінюють стан системи, від запитів, які повертають дані про стан системи. Цей спосіб організації коду сприяє чіткому структуруванню коду та забезпечує легку розширюваність функціональності системи [4]. 
     Також для організації архітектури застосунка було використано шаблон Mediator. Він дозволяє об'єктам взаємодіяти один з одним, не знаючи безпосередньо один про одного, що сприяє зменшенню залежностей між компонентами системи, тим самим збільшуючи стійкість та масштабованість системи.
     Архітектура серверного застосунка представлена на діаграмі пакетів (див. рис. 4.3). 
     
     
Рисунок 4.3 – Діаграма пакетів серверної частини програмної системи
     
     Приклади частин коду серверного застосунка представлено у додатку Б.
     Таким чином, було визначено технології й архітектуру серверної частини програмної системи.
     
     
     4.2 Архітектура IoT частини
     
     
     Користувачами IoT частини розробленої системи є 2 типи акторів: адміністратор та клієнт. Основними потребами клієнта є: можливість можливість відчинення/зачинення дверей автомобіля; можливість здійснення поїздки за заданим маршрутом; можливість зупинки автомобіля під час поїздки; отримання додаткових послуг під час поїздки. Основними потребами адміністратора є: можливість налаштування додаткових послуг для поїздок; отримання інформації про поточний стан автомобіля; сповіщення про загрози для автомобіля; можливість автомобіля автоматично вирушити до найближчої заправної станції у разі низької кількості палива. Взаємодію кожної ролі користувачів з IoT частиною системи представлено на діаграмі прецедентів (див. рис. 4.4). 
     

Рисунок 4.4 – Діаграма прецедентів IoT частини програмної системи
     
     Пристрій для IoT частини проєкту складається з мікроконтролера Arduino Uno, модуля ESP8266 WiFi, модуля Ublox NEO-6M, GPS антени, динаміка, акселерометра, і макетної плати (див. рис. 4.5). 
     

Рисунок 4.5 – Будова пристрою IoT частини програмної системи

     Усі зазначені частини мають безпосереднє з’єднання з мікроконтролером Arduino Uno та макетною платою. Макетна плата використовується для з’єднання виходів заземлення та навантаження модулів з відповідними виходами мікроконтролера Arduino Uno. 
     Виходи для читання (RX) і запису (TX) модуля ESP8266 WiFi мають з’єднання з цифровими виходами D9 та D8 відповідно мікроконтролера Arduino Uno. Зазначені цифрові виходи використовуються для потоків читання і запису для WiFi модуля, що дозволяє надсилання інформації до нього. Також цей модуль має підключення від цифрового виходу D4 до виходу читання (RX) на мікроконтролері Arduino Uno, що дозволяє надсилати інформацію від модуля до мікроконтролера. 
     Виходи для читання (RX) і запису (TX) модуля Ublox NEO-6M мають з’єднання з цифровими виходами D11 та D12 відповідно мікроконтролера Arduino Uno. Зазначені цифрові виходи використовуються для потоків читання і запису для GPS модуля, що дозволяє надсилання інформації до нього. Також цей модуль має підключення до GPS антени, що дозволяє отримувати актуальну інформацію про місцеположення з супутників. 
     Виходи потоку даних (SDA) і послідовного тактового генератора (SCL) акселерометра мають з’єднання з аналоговими виходами А4 та А5 відповідно мікроконтролера Arduino Uno. Зазначені цифрові виходи використовуються для потоків читання і запису для акселерометра, що дозволяє отримання інформації з нього. 
     Вихід динаміка має з’єднання з аналоговим виходом А0 мікроконтролера Arduino. Він дозволяє програвання звуку на динаміку.
     Для написання IoT частини системи було обрано мову програмування C++ для Arduino. У якості середовища розробки обрано Arduino IDE, оскільки воно надає необхідні бібліотеки для роботи з мікроконтролером Arduino. 
     Для програмування різних частин мікроконтролера Arduino Uno були використані бібліотеки SoftwareSerial, ArduinoUniqueID, TinyGPS++, MPU6050, ArduinoJSON. 
     Для програмування різних частин WiFi модуля ESP8266 були використані бібліотеки ESP8266WiFi, ESP8266HTTPClient, WiFiClientSecure, ArduinoJSON. 
     Для більш детальної візуалізації використаних пакетів було розроблено діаграму пакетів (див. рис. 4.6).
     
     

Рисунок 4.6 – Діаграма пакетів IoT частини програмної системи

     Бібліотеку SoftwareSerial було використано для створення потоків читання і запису на обраних цифрових виходах, що дозволило створення виділених потоків для окремих модулів, таких як ESP8266 WiFi модуль та Ublox NEO-6M GPS модуль. 
     Бібліотеку ArduinoUniqueID було використано для ідентифікації IoT пристрою в системі. Бібліотеку TinyGPS++ було використано для можливості роботи с даними і потоками GPS. 
     Бібліотеку MPU6050 було використано для можливості роботи з потоками і даними акселерометра. Бібліотеку ArduinoJSON було використано для можливості шифрування та розшифрування даних у форматі JSON, а також для роботи з ними. 
     Бібліотеку ESP8266HTTPClient було використано для можливості взаємодії з протоколом HTTP на модулі ESP8266. З її допомогою здійснюється відправлення та зчитування запитів з серверної частини. 
     Програмна частина пристрою складається з кодової частини для мікроконтролера Arduino Uno та кодової частини для модуля ESP8266 WiFi. Їхнє розподілення обумовлено тим, що зазначені апаратні частини пристрою потребують індивідуального програмування для роботи, на відміну від інших модулів, таких як GPS, акселерометр тощо. При цьому, ці кодові частини безпосередньо взаємодіють один з одним за допомогою потоків читання і запису, що дозволяє обмін даними між зазначеними компонентами. 
     Розроблено IoT частину за допомогою простої процедурної архітектури з використанням машини станів (State Machine) [5]. Основні дії в системі керуються станом, у якому знаходиться автомобіль. Наприклад, під час перебування в стані «у дорозі» система відправляє запит на отримання маршруту до місця призначення та дотримується його при русі. Це дозволяє організувати діяльність системи найпростішим та найбільш близьким до реального світу чином, без великої кількості абстракцій. 
     Основними станами в системі є «неактивний», «очікує», «у дорозі», «очікує пасажира», «у поїздці» та «обслуговується». Система починає роботу з «неактивного» стану – стан, коли немає живлення у пристрої. При подачі живлення система переходить у стан «очікує». Під час очікування система перевіряє кількість палива автомобіля. Якщо його недостатньо, то відбувається перехід у стан «обслуговується», і автомобіль вирушає до найближчої заправної станції. Після заправлення система повертається до стану очікування. Також відбувається перевірка на те, чи є активна поїздка призначена для цього автомобіля. Якщо така умова виконується, відбувається перехід до стану «у дорозі», під час якого автомобіль вирушає до місця вивезення клієнта. Після того, як автомобіль досягнув місця вивезення, він переходить у стан «очікує пасажира». Коли клієнт розпочинає поїздку, система переходить у стан «у поїздці». Під час поїздки клієнт може зупинити автомобіль, що поверне його у стан «очікує пасажира». Після досягнення місця призначення, система повертається до стану «очікує». 
     Для більш детальної візуалізації станів системи було розроблено діаграму станів (див. рис. 4.7).
     

Рисунок 4.7 – Діаграма станів IoT частини програмної системи
     
     Взаємодія пристроя з користувачем починається з його увімкнення, потім під’єднання до WiFi і GPS. Далі, коли отримано дані про активну поїздку для цього автомобіля, виконується перевірка кількості палива. При нестачі палива, автомобіль вирушає до найближчої заправної станції. Коли палива достатньо, автомобіль вирушає до місця вивезення клієнта. Після досягнення місця вивезення, автомобіль очікує на клієнта. Коли клієнт розпочав поїздку, пристрій вирушає до місця призначення. Після досягнення місця призначення, коли клієнт завершив поїздку, автомобіль повертається до отримання даних про наступну активну поїздку. На основі описаної взаємодії пристрою с користувачем було побудовано діаграму взаємодії (див. рис. 4.8).
     

Рисунок 4.8 – Діаграма взаємодії IoT частини програмної системи

     Діяльність системи можна описати як взаємодію пристроя і серверної частини. Робота пристроя починається з його увімкнення, потім під’єднання до WiFi і GPS. На основі описаної діяльності пристрою було побудовано діаграму діяльності, що відображає взаємодію пристрою з сервером (див. рис. 4.9). 
     

Рисунок 4.9 – Діаграма діяльності IoT частини програмної системи
     
     Таким чином, за допомогою діаграм пакетів, станів та діяльності було визначено основні технології та архітектуру системи. 
     Приклади коду IoT частини системи для мікроконтролера Arduino Uno представлено у додатку В.1. 
     Приклади коду IoT частини системи для модуля ESP8266 WiFi представлено у додатку В.2.
     
     
     4.3 Архітектура клієнтської частини
     
     
     Користувачами клієнтської частини розробленої системи є 2 типи акторів: адміністратор та клієнт.
     Основними потребами клієнта є: можливість перегляду доступних автомобілів, які можуть здійснити поїздку за вказаними початковою та кінцевою адресою: можливість замовлення поїздки на обраному автомобілі; можливість перегляду інформації про власні поїздки; можливість перегляду інформації про обрану поїздку; можливість скасування поїздки; можливість оновлення додаткових послуг для поїздки. 
     Основними потребами адміністратора є: можливість перегляду та керування користувачами системи; можливість створення, редагування, видалення автономних автомобілів в системі; можливість перегляду місцезнаходження обраного автомобіля на карті; можливість налаштування автономних автомобілів в системі; можливість створення, редагування, видалення додаткових послуг для поїздок; можливість створення резервних копій даних системи та їхній імпорт в систему; можливість керування сертифікатами системи, робити їхній експорт та імпорт в систему.
     Взаємодію кожної ролі користувачів з клієнтською частиною системи представлено на діаграмі прецедентів (див. рис. 4.10).
     

Рисунок 4.10 – Діаграма прецедентів клієнтської частини програмної системи
     
     Для написання клієнтської частини системи було обрано мову програмування TypeScript з використанням технології React, що забезпечує високу швидкодію розробки і зручність у використанні за рахунок статичної типізації та компонентного підходу.
     Для реалізації елементів інтерфейсу було використано бібліотеки Material UI, які надають готові та стилізовані компоненти інтерфейсу для швидкої і зручної розробки візуально привабливого вебзастосунку.
     Для реалізації візуалізації місцезнаходження було використано бібліотеку MapBox-GL, яка забезпечує потужні можливості географічного візуалізації та взаємодії з картографічними об'єктами для створення динамічних та інтерактивних карт.
     Для реалізації локалізації інтерфейсу було використано бібліотеку i18next, що дозволяє легко і ефективно впроваджувати багатомовний інтерфейс та забезпечує зручний механізм перекладу текстових рядків.
     Для реалізації навігації по сайту використано бібліотеку react-router-dom, яка надає зручні та потужні інструменти для створення реактивної навігації та управління маршрутами вебзастосунку.
     Для виконання асинхронних запитів на сервер використано бібліотеку axios, яка забезпечує зручний та потужний інтерфейс для взаємодії з HTTP-запитами та дозволяє легко обробляти відповіді від сервера.
     Для розгортання серверу використано інструмент побудови Vite, який надає швидкий та ефективний спосіб розгортання вебзастосунку, дозволяючи легко налаштовувати середовище розробки та підтримує автоматичне оновлення в реальному часі. 
     Для візуалізації використаних пакетів було розроблено діаграму пакетів (див. рис. 4.11).
     

Рисунок 4.11 – Діаграма пакетів клієнтської частини програмної системи
     
     Розроблено клієнтську частину за допомогою Feature-Sliced архітектури. Вона визначає побудову проєкту за допомогою шарів. 
     Шари включають зрізи, які в свою чергу включають сегменти. Шари – це каталоги верхнього рівня застосунку. У проєкті визначено 7 шарів: app, pages, components, features, interfaces, context та hooks. Шар app визначає основну конфігурацію застосунку. Шар pages містить сторінки сайту. Шар components містить різні компоненти інтерфейсу, які доступні для повторного використання. Шар features відповідає за функціонал застосунку. Він визначає дії, доступні користувачу в системі. Шар interfaces визначає інтерфейси моделей, які використовуються для обміну даними з сервером та їхнього представлення на сторінках. Шар context визначає об’єкти контексту, які дозволяють передачу даних іншим компонентам, які відповідають контексту. Шар hooks відповідає за об’єкти хуків, які дозволяють компонентам отримувати доступ до станів системи. 
     Для більш детальної візуалізації архітектури системи було розроблено діаграму компонентів (див. рис. 4.12).
     

Рисунок 4.12 – Діаграма компонентів клієнтської частини програмної системи

     Взаємодія користувача з клієнтською частиною починається з введення даних профілю (при реєстрації або входу). Після авторизації, згідно ролі користувача, взаємодія розділяється на клієнтську та адміністраторську.
     Клієнт має можливість замовити поїздку. Для цього він вводить адреси, за якими бажає здійснити поїздку, після чого система підбирає доступні автомобілі для поїздки  та надає користувачеві можливість вибору бажаного автомобіля. Коли користувач обрав автомобіль, він може створити поїздку. Також клієнт має можливість переглянути інформацію про власні поїздки. Далі він може оновити додаткові послуги для поїздки, або скасувати наявну.
     Адміністратор має можливість виконувати керування даними системи з панелі адміністратора. Там йому доступні можливості експортування даних системи, імпортування даних системи, експортування сертифікатів системи, імпортування сертифікатів системи, можливості керування користувачами системи. Також він може переглянути наявні в системі автомобілі, та здійснювати керування ними, або переглянути місцеположення обраного автомобіля на карті.
     Для більш детальної візуалізації взаємодії користувачів з клієнтської частиною системи було розроблено діаграму взаємодії (див. рис. 4.13). 
     

Рисунок 4.13 – Діаграма взаємодії клієнтської частини програмної системи

     Приклади коду клієнтської частини системи представлено у додатку Г.
     Таким чином, було визначено технології й архітектуру клієнтської частини програмної системи.

5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
     5.1 Виклик і завантаження
     
     
     Для виклику програми необхідно завантажити архів, у якому вона розповсюджується, та розархівувати її. Оскільки у програмному продукті використовується з’єднання із СУБД PostgreSQL, необхідно встановити її останню версію з офіційного сайту виробника. 
     Щоб забезпечити з’єднання застосунку з базою даних, потрібно відкрити файл appsettings.json за шляхом «apz-pzpi-21-1-volovyi-artem\Task2\apz-pzpi-21-1-volovyi-artem-task2\AutoCab.Server» за допомогою будь-якого текстового редактора та змінити вміст рядку, виділеного червоним на рисунку 5.1, у відповідності до інформації, яка є необхідною для входу до бази даних, встановленої на комп'ютері.


Рисунок 5.1 – Рядок підключення у файлі appsettings.json

     Далі необхідно запустити серверну та клієнтську частини системи. Для цього можна використати засоби середовища розробки Visual Studio, яку необхідно завантажити з офіційного сайту виробника. Відкривши AutoCab.sln у теці «apz-pzpi-21-1-volovyi-artem», треба натиснути на «Start» у верхній панелі.
     Для запуску IoT частини необхідно встановити середовище розробки Arduino IDE з офіційного сайту виробника. Далі, за допомогою мікроконтролера Arduino Uno, модуля ESP8266 WiFi, модуля Ublox NEO-6M, GPS антени, динаміка, акселерометра, і макетної плати відтворити схему підключення, зображену на рис.  рис. 4.5. Після цього необхідно за допомогою Arduino IDE відкрити файл Aduino.ino за шляхом «apz-pzpi-21-1-volovyi-artem\Task3\apz-pzpi-21-1-volovyi-artem-task3\AutoCab.IoT\Arduino» та завантажити програму на мікроконтролер Arduino UNO. Далі необхідно за допомогою Arduino IDE відкрити файл ESP8266.ino за шляхом «apz-pzpi-21-1-volovyi-artem\Task3\apz-pzpi-21-1-volovyi-artem-task3\AutoCab.IoT\ESP8266» та змінити вміст рядків WIFI_SSID та WIFI_PASS на відповідні налаштування WiFi. Вміст рядка HOST необхідно замінити на адресу, за якою працює серверна частина системи. Після цього завантажити програму на модуль ESP8266 WiFi.
     
     
     5.2 Призначення і логічна структура
     
     
     Функції, які може виконувати програма, можна розбити на декілька модулів, а саме:
* авторизація та реєстрація;
* поїздки;
* автомобілі;
* послуги;
* дані системи;
* сертифікати системи;
* користувачі системи;
* геолокація.
     Модуль «Авторизація та реєстрація» містить у собі функції для входу в систему та створення нового облікового запису. Реєстрація дозволяє клієнту створити свій запис у базі даних та надалі отримувати до нього доступ за допомогою свого логіну та пароля. За замовчуванням, для доступу до облікового запису адміністратора необхідно авторизуватися з поштою admin@i.ua і паролем string12.
     Модуль «Поїздки» містить у собі функції для перегляду, додавання, редагування та скасування поїздок клієнтів. Також клієнт може оновити додаткові послуги для поїздки, додаючи або видаючи їх з обраної поїздки.
     Модуль «Автомобілі» містить у собі функції для перегляду, додавання, редагування та видалення автомобілів.
     Модуль «Послуги» містить у собі функції для перегляду, додавання, редагування та видалення додаткових послуг, які може надавати автомобіль під час поїздки.
     Модуль «Дані системи» є адміністраторським, і містить у собі функції для експорту та імпорту даних системи.
     Модуль «Сертифікати системи» є адміністраторським, і містить у собі функції для експорту та імпорту сертифікатів системи.
     Модуль «Користувачі системи» є адміністраторським, і містить у собі функції для керування користувачами системи.
     Модуль «Геолокація» містить у собі функції для геолокації автомобілів та прокладання маршрутів. Їх переважно використовує IoT частина, проте також наявна можливість використовувати їх для візуалізації місцеположень і маршрутів для кращого інформування користувача. 
	

     5.3 Опис програмної реалізації


     При відкритті клієнтського застосунка можна побачити головну сторінку (див. рис. 5.2). 
     З неї можна перейти до сторінки авторизації, а також налаштувати локалізацію сайту, натиснувши на символ локалізації у правому верхньому куті сайту. На вибір доступні англійська та українська мови. На сайті також присутня інтернаціоналізація, яка залежить від регіону браузера.
     

Рисунок 5.2 – Головна сторінка сайту
     
     На сторінці авторизації (див. рис. 5.3) необхідно обрати: створити обліковий запис клієнта або увійти в систему.


Рисунок 5.3 – Сторінка авторизації

     При створенні нового облікового запису треба увести електронну пошту та пароль нового користувача (див. рис. 5.4).
     

Рисунок 5.4 – Сторінка реєстрації
     
     При входу в обліковий запис треба увести електронну пошту та пароль наявного користувача. Також можна перейти до сторінки реєстрації (див. рис. 5.5).
     

Рисунок 5.5 – Сторінка входу в систему

     Після входу користувач отримує доступ до сторінок «Мої поїздки» та «Створити поїздку». Розглянемо сторінку створення поїздки (див. рис 5.6).


Рисунок 5.6 – Сторінка створення поїздки

	Користувачу необхідно увести початкову адресу, адресу призначення та обрати автомобіль, який може здійснити поїздку за вказаними адресами (див. рис. 5.7). Після цього можна створити поїздку.


Рисунок 5.7 – Обрання автомобіля за вказаними адресами

	Свої поїздки можна переглянути на сторінці «Мої поїздки» (див. рис. 5.8)


Рисунок 5.8 – Сторінка поїздок користувача

	Користувач може переглядати детальну інформацію про кожну поїздку. Також можна скасувати поїздку або оновити додаткові послуги для поїздки (див. рис. 5.9)


Рисунок 5.9 – Вікно зміни додаткових послуг поїздки

	Далі розглянемо сторінку адміністратора. Після входу в систему з обліковим записом адміністратора, у верхній панелі можна побачити вкладку «Панель адміністратора» (див. рис. 5.10).


Рисунок 5.10 – Головна сторінка з облікового запису адміністратора

	При переході до сторінки панелі адміністратора, можна побачити засоби для експорту/імпорту даних системи (див. рис. 5.11). 


Рисунок 5.11 – Сторінка панелі адміністратора

     При натисненні на «Експорт бази даних» на пристрій користувача завантажується файл «database.tar», який містить усі дані та налаштування бази даних застосунку.
     При натисненні на «Імпорт бази даних» від користувача очікується файл з розширенням tar з усіма даними та налаштуваннями бази даних, що імпортується.
     Також нижче можна побачити засоби управління сертифікатами системи.
     Наявне табличне подання інформації про поточний сертифікат, який використовується в системі. 
     При натисненні на «Експорт сертифіката» на пристрій користувача завантажується файл «certificate.pfx», який містить сертифікат.
     При натисненні на «Імпорт сертифіката» від користувача очікується файл з розширенням pfx з сертифікатом, що імпортується.
     Також ще нижче можна побачити табличні подання інформації про користувачів, поїздки, послуги та автомобілі (див. рис. 5.12, 5.13).
     

Рисунок 5.12 – Таблиці користувачів та поїздок


Рисунок 5.13 – Таблиці послуг та автомобілів

     Вони дозволяють здійснювати додавання, редагування та видалення користувачів системи, їхніх поїздок, а також додаткових послуг та автомобілів мережі. Після зміни інформації в таблицях, для її збереження, необхідно натиснути на «Зберегти зміни».
     У таблиці автомобілів також наявна можливість перегляду місцеположення обраного автомобіля. Для цього в таблиці автомобілів необхідно натиснути на рядок з необхідним автомобілем та натиснути «Переглянути місцезнаходження». Після цього відкриється вікно з картою, на якій помічено місцеположення автомобіля (див. рис. 5.14).
     

Рисунок 5.14 – Перегляд місцеположення автомобіля на карті

	Таким чином, було описано можливості взаємодії користувача з розробленою програмною системою.
	Запис результатів функціонального тестування доступний за посиланням: https://youtu.be/qWI9q3g0Hm4?si=IhfeNFiJZ_1hSzuB (дата звернення: 13.06.2024).

ВИСНОВКИ


     За результатами виконання роботи було розроблено програмну систему на основі предметної області «Мережа таксі автономного керування».
     У процесі роботи було проаналізовано предметну область, спроектовано структуру бази даних, розроблено архітектуру серверної, IoT та клієнтської частин програмної системи та реалізовано її програмними засобами ASP.NET Core, Arduino та React.js.
     Розроблена програмна система дозволяє користувачам зручно організовувати свої поїздки за допомогою автономних автомобілів. Вона забезпечує реєстрацію та авторизацію користувачів, керування інформацією про поїздки. Користувачі можуть обирати спеціальні умови поїздки, а також визначати місця зупинок по дорозі. Система забезпечує моніторинг статусу та місцезнаходження автомобілів у реальному часі, а також дозволяє відкривати та закривати двері автомобіля, розпочинати або завершувати маршрут. Крім того, в системі наявні можливості адміністрування, такі як: керування користувачами системи, керування даними та налаштуваннями системи, експорт та імпорт даних та сертифікатів.
     

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


     1. PostgreSQL 16.3 Documentation. PostgreSQL Documentation. URL: https://www.postgresql.org/docs/16/index.html (дата звернення: 25.05.2024).
     2. ASP.NET documentation. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0 (дата звернення: 25.05.2024).
     3. React Reference Overview – React. URL: https://react.dev/reference/react (дата звернення: 25.05.2024).
     4. Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley Professional Computing Series) / R. Helm та ін. Addison-Wesley Professional, 1995. 395 р.
     5. Kamal R. Embedded Systems - Architecture, Programming and Design. Tata McGraw Hill, 2008.


ДОДАТОК А
Результат перевірки на плагіат



Рисунок А.1 – Результат перевірки на плагіат


ДОДАТОК Б
Програмний код серверної частини
     Б.1 Код основного файлу для роботи сервера Program.cs:
     
     
1 using System.Reflection;
2 using AutoCab.Db;
3 using AutoCab.Server.BuildInjections;
4
5 var builder = WebApplication.CreateBuilder(args);
6
7 builder.Services.AddControllers();
8
9 builder.Services.AddEndpointsApiExplorer();
10 builder.Services.AddSetSwagger();
11
12 builder.Services.AddMediatR(configuration =>
13
configuration.RegisterServicesFromAssembly(Assembly.GetExecutingAssemb
ly()));
14
15 builder.Services.AddLogging();
16
17 builder.Services.AddServices();
18 builder.Services.AddSetSecurity(builder.Configuration);
19 builder.Services.AddCors();
20
21 builder.Services.AddDbSetup(builder.Configuration);
22
23 builder.Services.AddAutoMapper(Assembly.GetExecutingAssembly());
24
25 var app = builder.Build();
26
27 app.UseSwagger();
28 app.UseSwaggerUI();
29
30 app.UseHttpsRedirection();
31 app.UseCors(CorsInjection.PolicyName);
32
33 app.UseAuthentication();
34 app.UseAuthorization();
35
36 app.MapControllers();
37
38 app.Run();



     Б.2 Код контролера для роботи з даними системи:
     
     
1 using AutoCab.Db.DbContexts;
2 using AutoCab.Server.Controllers.Base;
3 using AutoCab.Server.Extensions;
4 using AutoCab.Shared.Dto.Error;
5 using AutoCab.Shared.Helpers;
6 using AutoMapper;
7 using MediatR;
8 using Microsoft.AspNetCore.Authorization;
9 using Microsoft.AspNetCore.Mvc;
10 using System.Diagnostics;
11 using System.Text;
12 
13 namespace AutoCab.Server.Controllers;
14 
15 [Route("api/[controller]")]
16 [ApiController]
17 public class DataController : BaseController
18 {
19     private readonly ApplicationDbContext _context;
20     private readonly IConfiguration _configuration;
21 
22     public DataController(IMapper mapper, IMediator mediator,
23         ApplicationDbContext context, IConfiguration configuration)
24         : base(mapper, mediator)
25     {
26         _context = context;
27         _configuration = configuration;
28     }
29 
30     [HttpGet("export-database")]
31     [Authorize(Roles = Roles.Administrator)]
32     [ProducesResponseType(typeof(FileContentResult), 200)]
33     [ProducesResponseType(typeof(ErrorDto), 400)]
34     [FileDownload(FileName = "database.tar")]
35     public IActionResult ExportDatabase()
36     {
37         var startInfo = new ProcessStartInfo
38         {
39             FileName = @"C:\Program Files\PostgreSQL\16\bin\pg_dump.exe",
40             Arguments = $"-U {_configuration["DatabaseUsername"]} -F t {_configuration["DatabaseName"]}",
41             RedirectStandardOutput = true,
42             UseShellExecute = false,
43             CreateNoWindow = true,
44         };
45 
46         startInfo.Environment["PGPASSWORD"] = _configuration["DatabasePassword"];
47 
48         var process = new Process { StartInfo = startInfo };
49         process.Start();
50 
51         using var ms = new MemoryStream();
52         process.StandardOutput.BaseStream.CopyTo(ms);
53 
54         var bytes = ms.ToArray();
55         return new FileContentResult(bytes, "application/octet-stream");
56     }
57 
58     [HttpPost("import-database")]
59     [Authorize(Roles = Roles.Administrator)]
60     public async Task<IActionResult> ImportDatabase(IFormFile file)
61     {
62         if (file == null || file.Length == 0)
63         {
64             return BadRequest("No file uploaded");
65         }
66 
67         var tempFilePath = Path.GetTempFileName();
68 
69         using (var stream = System.IO.File.Create(tempFilePath))
70         {
71             await file.CopyToAsync(stream);
72         }
73 
74         var startInfo = new ProcessStartInfo
75         {
76             FileName = @"C:\Program Files\PostgreSQL\16\bin\pg_restore.exe",
77             Arguments = $"-U {_configuration["DatabaseUsername"]} -c -d {_configuration["DatabaseName"]} -F t {tempFilePath}",
78             UseShellExecute = false,
79             CreateNoWindow = true,
80             RedirectStandardError = true
81         };
82 
83         startInfo.Environment["PGPASSWORD"] = _configuration["DatabasePassword"];
84 
85         var process = new Process
86         {
87             StartInfo = startInfo,
88             EnableRaisingEvents = true
89         };
90         var stderr = new StringBuilder();
91         process.ErrorDataReceived += (sender, args) => stderr.AppendLine(args.Data);
92 
93         process.Start();
94         process.BeginErrorReadLine();
95         process.WaitForExit();
96 
97         System.IO.File.Delete(tempFilePath);
98 
99         if (process.ExitCode != 0)
100         {
101             return StatusCode(StatusCodes.Status500InternalServerError, stderr.ToString());
102         }
103 
104         return Ok("Database imported successfully");
105     }
106 }
     
     
     Б.3 Код команди для отримання списку автомобілів які можуть здійснити поїздку за вказаними адресами:
     
     
1 using AutoCab.Db.DbContexts;
2 using AutoCab.Db.Models;
3 using AutoCab.Server.Features.Base;
4 using AutoCab.Server.Services;
5 using AutoCab.Shared.Dto.Car;
6 using AutoCab.Shared.Dto.Geolocation;
7 using AutoCab.Shared.Errors.ServiceErrors;
8 using AutoCab.Shared.ServiceResponseHandling;
9 using AutoMapper;
10 using MediatR;
11 using Microsoft.EntityFrameworkCore;
12 using System.Collections.ObjectModel;
13 
14 namespace AutoCab.Server.Features.Car;
15 
16 public class GetCarsForTripQuery : GetCarsForTripQueryDto, IRequest<ServiceResponse<ICollection<CarForTripDto>>>
17 {
18     public class GetAvailableCarsQueryHandler : 
19         ExtendedBaseHandler<GetCarsForTripQuery, ServiceResponse<ICollection<CarForTripDto>>>
20     {
21         private readonly IGeolocationService _geolocationService;
22 
23         public GetAvailableCarsQueryHandler(ApplicationDbContext context, IHttpContextAccessor contextAccessor,
24             IMapper mapper, IGeolocationService geolocationService, ILogger<GetAvailableCarsQueryHandler> logger)
25             : base(context, contextAccessor, mapper, logger)
26         {
27             _geolocationService = geolocationService;
28         }
29 
30         public override async Task<ServiceResponse<ICollection<CarForTripDto>>> Handle(GetCarsForTripQuery request,
31             CancellationToken cancellationToken)
32         {
33             try
34             {
35                 return await UnsafeHandleAsync(request, cancellationToken);
36             }
37             catch (Exception ex)
38             {
39                 Logger.LogError(ex, "Get cars for trip error");
40                 return ServiceResponseBuilder.Failure<ICollection<CarForTripDto>>(CarError.GetCarsError);
41             }
42         }
43 
44         protected override async Task<ServiceResponse<ICollection<CarForTripDto>>> UnsafeHandleAsync(
45             GetCarsForTripQuery request, CancellationToken cancellationToken)
46         {
47             var availableCars = await Context.Cars
48                 .Where(car => car.Status == CarStatus.Idle || car.Status == CarStatus.WaitingForPassenger)
49                 .ToListAsync(cancellationToken);
50 
51             var carsForTrip = new List<CarForTripDto>();
52             foreach (var car in availableCars)
53             {
54                 if (car.Location == null)
55                 {
56                     continue;
57                 }
58 
59                 var carLocation = new LocationDto { X = car.Location.X, Y = car.Location.Y };
60                 var startLocation = await _geolocationService.GetAddressLocationAsync(request.StartAddress);
61                 
62                 if (!startLocation.IsSuccess)
63                 {
64                     continue;
65                 }
66 
67                 var routeToStartLocation = await _geolocationService.GetRoutesAsync(carLocation, startLocation.Result);
68 
69                 if (!routeToStartLocation.IsSuccess)
70                 {
71                     continue;
72                 }
73 
74                 var distanceToStartLocation = routeToStartLocation.Result.Routes[0].Distance;
75 
76                 var endLocation = await _geolocationService.GetAddressLocationAsync(request.DestinationAddress);
77 
78                 if (!endLocation.IsSuccess)
79                 {
80                     continue;
81                 }
82 
83                 var routeToDestinationLocation = await _geolocationService.GetRoutesAsync(startLocation.Result, endLocation.Result);
84 
85                 if (!routeToDestinationLocation.IsSuccess)
86                 {
87                     continue;
88                 }
89 
90                 var distanceToDestinationLocation = routeToDestinationLocation.Result.Routes[0].Distance;
91 
92                 decimal totalDistance = Convert.ToDecimal(distanceToStartLocation + distanceToDestinationLocation);
93 
94                 var carForTrip = Mapper.Map<CarForTripDto>(car);
95                 carForTrip.Price = CalculatePrice(totalDistance);
96                 carsForTrip.Add(carForTrip);
97             }
98 
99             var sortedCars = carsForTrip.OrderBy(car => car.Price).ToList();
100             var result = new Collection<CarForTripDto>(sortedCars);
101             return ServiceResponseBuilder.Success((ICollection<CarForTripDto>)result);
102         }
103 
104         private decimal CalculatePrice(decimal distance)
105         {
106             decimal pricePerM = 0.025M;
107             return distance * pricePerM;
108         }
109     }
110 }
     
     
     Б.4 Код запиту для створення поїздки:
     
     
1 using AutoCab.Db.DbContexts;
2 using AutoCab.Server.Extensions;
3 using AutoCab.Server.Features.Base;
4 using AutoCab.Shared.Dto.Trip;
5 using AutoCab.Shared.Errors.ServiceErrors;
6 using AutoCab.Shared.ServiceResponseHandling;
7 using AutoMapper;
8 using MediatR;
9 
10 namespace AutoCab.Server.Features.Trip;
11 
12 public class CreateTripCommand : CreateTripCommandDto, IRequest<ServiceResponse<TripInfoDto>>
13 {
14     public class CreateTripCommandHandler :
15         ExtendedBaseHandler<CreateTripCommand, ServiceResponse<TripInfoDto>>
16     {
17         public CreateTripCommandHandler(ApplicationDbContext context, IHttpContextAccessor contextAccessor,
18             IMapper mapper, ILogger<CreateTripCommandHandler> logger)
19             : base(context, contextAccessor, mapper, logger)
20         {
21         }
22 
23         public override async Task<ServiceResponse<TripInfoDto>> Handle(CreateTripCommand request,
24             CancellationToken cancellationToken)
25         {
26             try
27             {
28                 return await UnsafeHandleAsync(request, cancellationToken);
29             }
30             catch (Exception ex)
31             {
32                 Logger.LogCritical(ex, "Trip creation error");
33                 return ServiceResponseBuilder.Failure<TripInfoDto>(TripError.TripCreateError);
34             }
35         }
36 
37         protected override async Task<ServiceResponse<TripInfoDto>> UnsafeHandleAsync(CreateTripCommand request,
38             CancellationToken cancellationToken)
39         {
40             var isUserIdValid = ContextAccessor.TryGetUserId(out var userId);
41             var customer = await Context.Users.FindAsync(userId);
42 
43             if (!isUserIdValid || customer == null)
44             {
45                 return ServiceResponseBuilder.Failure<TripInfoDto>(UserError.InvalidAuthorization);
46             }
47 
48             var newTrip = Mapper.Map<Db.Models.Trip>(request);
49             newTrip.User = customer;
50             newTrip.StartDateTime = DateTime.UtcNow;
51             newTrip.Status = Db.Models.TripStatus.Created;
52             
53             ValidateAddresses(ref newTrip);
54 
55             Context.Add(newTrip);
56 
57             await Context.SaveChangesAsync(cancellationToken);
58 
59             var result = Mapper.Map<TripInfoDto>(newTrip);
60             result.UserId = customer.Id;
61 
62             return ServiceResponseBuilder.Success(result);
63         }
64 
65         private void ValidateAddresses(ref Db.Models.Trip trip)
66         {
67             var existingStartAddress = Context.Addresses.Find(trip.StartAddress.Id);
68 
69             if (existingStartAddress != null)
70             {
71                 trip.StartAddress = null;
72             }
73 
74             var existingDestinationAddress = Context.Addresses.Find(trip.DestinationAddress.Id);
75 
76             if (existingDestinationAddress != null)
77             {
78                 trip.DestinationAddress = null;
79             }
80         }
81     }
82 } 

ДОДАТОК В
Програмний код IoT пристрою
     В.1 Код основного файлу для роботи мікроконтролера Arduino
     
     
1 #include <SoftwareSerial.h>
2 #include <ArduinoUniqueID.h>
3 #include <ArduinoJson.h>
4 #include <TinyGPS++.h>
5 #include <Wire.h>
6 #include "carstatus.h"
7 #include "commands.h"
8 
9 const int SPEAKER_PIN = A0;
10 
11 const int DEFAULT_DELAY = 3000;
12 const int FUEL_DECREMENT_INTERVAL = 15000;
13 
14 const int MPU_ADDRESS = 0x68;  // I2C address of the MPU-6050
15 
16 SoftwareSerial espSerial(8, 9); // Serial to transfer data to ESP8266 module
17 SoftwareSerial gpsSerial(11, 12); // Serial to transfer data to GPS module
18 
19 TinyGPSPlus gps;
20 
21 String deviceId;
22 
23 int currentDelay;
24 CarStatus currentStatus;
25 String doorStatus;
26 
27 bool isTripActive;
28 bool isDestinationReached;
29 bool isVoiceAssistantOn;
30 
31 unsigned long currentMillis = 0;
32 unsigned long previousMillis = 0;
33 
34 int fuelLevel = 100;
35 
36 int16_t acX, acY, acZ, tmp, gyX, gyY, gyZ;
37 
38 void setup() {
39   Serial.begin(115200);
40   espSerial.begin(115200);
41   gpsSerial.begin(9600);
42 
43   while (!Serial) {
44   ; // wait for serial port to connect. Needed for native USB port only
45   }
46 
47   pinMode(SPEAKER_PIN, OUTPUT);
48 
49   Wire.begin();
50   Wire.beginTransmission(MPU_ADDRESS);
51   Wire.write(0x6B);  // PWR_MGMT_1 register
52   Wire.write(0);     // set to zero (wakes up the MPU-6050)
53   Wire.endTransmission(true);
54 
55   deviceId = getDeviceId();
56   currentDelay = DEFAULT_DELAY;
57   currentStatus = CarStatus::Idle;
58   doorStatus = DOOR_CLOSED_COMMAND;
59 }
60 
61 void loop() {
62   currentMillis = millis();
63   handleCarStatus();
64   handleFuel();
65   handleAccelerometer();
66   handleServices();
67   smartDelay(currentDelay);
68   sendCarData();
69 }
70 
71 void handleCarStatus() {
72   Serial.println("Current status: " + String((int)currentStatus));
73 
74   if (currentStatus == CarStatus::Idle) {
75     if (isTripActive) {
76       Serial.println("Trip started");
77       currentStatus = CarStatus::EnRoute;
78     }
79   }
80 
81   if (currentStatus == CarStatus::EnRoute) {
82     if (isDestinationReached) {
83       Serial.println("Waiting for passenger");
84       currentStatus = CarStatus::WaitingForPassenger;
85     }
86   }
87 
88   if (currentStatus == CarStatus::WaitingForPassenger) {
89     isDoorOpen();
90   }
91 }
92 
93 bool isDoorOpen() { 
94   if (doorStatus == DOOR_OPEN_COMMAND) {
95     Serial.println("Door open");
96     return true;
97   }
98   if (doorStatus == DOOR_CLOSED_COMMAND) {
99     Serial.println("Door closed");
100     return false;
101   }
102   return false;
103 }
104 
105 void smartDelay(unsigned long interval) {
106   if (currentMillis - previousMillis >= interval) {
107     previousMillis = currentMillis;
108     unsigned long start = millis();
109     do {
110       readFromGPS();
111       readFromESP();
112     } while (millis() - start < interval);
113   }
114 }
115 
116 void readFromESP() {
117   if (!Serial.available()) {
118     return;
119   }
120 
121   String response = Serial.readString();
122   response.trim();
123 
124   if (response.length() > 0) {
125     Serial.println("Received data: " + response);
126 
127     if (response.indexOf(DOOR_OPEN_COMMAND) != - 1 || response.indexOf(DOOR_CLOSED_COMMAND) != -1) {
128       doorStatus = response.substring(response.indexOf(DOOR_OPEN_COMMAND), response.indexOf("\n"));
129     }
130     if (response.indexOf(TRIP_ACTIVE_COMMAND) != -1) {
131       isTripActive = true;
132     }
133     if (response.indexOf(DESTINATION_REACHED_COMMAND) != -1) {
134       isDestinationReached = true;
135     }
136     if (response.indexOf(CAR_STOPPED_COMMAND) != -1) {
137       currentStatus = CarStatus::WaitingForPassenger;
138     }
139     if (response.indexOf(CAR_STARTED_COMMAND) != -1) {
140       currentStatus = CarStatus::OnTrip;
141     }
142     if (response.indexOf(LOW_FUEL_COMMAND) != -1) {
143       currentStatus = CarStatus::Maintenance;
144     }
145     if (response.indexOf(SERVICES_COMMANDS[0]) != -1) {
146       isVoiceAssistantOn = true;
147     }
148   }
149 }
150 
151 void readFromGPS() {
152   while (gpsSerial.available()) {
153     gps.encode(gpsSerial.read());
154   }
155 }
156 
157 void handleFuel() {
158   static unsigned long previousFuelDecrement = 0;
159   if (currentMillis - previousFuelDecrement >= FUEL_DECREMENT_INTERVAL) {
160     previousFuelDecrement = currentMillis;
161     if (fuelLevel > 0) {
162       fuelLevel -= 1; 
163     } else {
164       Serial.println("Out of fuel!");
165       currentStatus = CarStatus::Inactive;
166     }
167   }
168 }
169 
170 void handleAccelerometer() {
171   Wire.beginTransmission(MPU_ADDRESS);
172   Wire.write(0x3B);  // starting with register 0x3B (ACCEL_XOUT_H)
173   Wire.endTransmission(false);
174   Wire.requestFrom(MPU_ADDRESS, 14, true);  // request a total of 14 registers
175   acX=Wire.read()<<8|Wire.read();  // 0x3B (ACCEL_XOUT_H) & 0x3C (ACCEL_XOUT_L)     
176   acY=Wire.read()<<8|Wire.read();  // 0x3D (ACCEL_YOUT_H) & 0x3E (ACCEL_YOUT_L)
177   acZ=Wire.read()<<8|Wire.read();  // 0x3F (ACCEL_ZOUT_H) & 0x40 (ACCEL_ZOUT_L)
178   tmp=(Wire.read()<<8|Wire.read()) / 340.00 + 36.53;  // 0x41 (TEMP_OUT_H) & 0x42 (TEMP_OUT_L)
179   gyX=Wire.read()<<8|Wire.read();  // 0x43 (GYRO_XOUT_H) & 0x44 (GYRO_XOUT_L)
180   gyY=Wire.read()<<8|Wire.read();  // 0x45 (GYRO_YOUT_H) & 0x46 (GYRO_YOUT_L)
181   gyZ=Wire.read()<<8|Wire.read();  // 0x47 (GYRO_ZOUT_H) & 0x48 (GYRO_ZOUT_L)
182 }
183 
184 void handleServices() {
185   if (isVoiceAssistantOn) {
186     tone(SPEAKER_PIN, 300, 600);
187   }
188 }
189 
190 void sendCarData() {
191   StaticJsonDocument<96> doc;
192 
193   doc["deviceId"] = deviceId;
194   doc["status"] = (int)currentStatus;
195   doc["isDoorOpen"] = (doorStatus == DOOR_OPEN_COMMAND);
196   doc["fuel"] = fuelLevel;
197   doc["temperature"] = tmp;
198 
199   JsonObject location = doc.createNestedObject("location");
200   
201   location["x"] = gps.location.lng();
202   location["y"] = gps.location.lat();
203 
204   char jsonBuffer[192]; 
205   serializeJson(doc, jsonBuffer, 192);
206   Serial.println(jsonBuffer);
207   espSerial.println(jsonBuffer);
208 }
209 
210 String getDeviceId() {
211   String deviceId;
212   for (size_t i = 0; i < UniqueIDsize; i++) {
213     deviceId += String(UniqueID[i], HEX);
214   }
215   deviceId.toUpperCase();
216   return deviceId;
217 }
     
     
     В.2 Код основного файлу для роботи ESP8266 WiFi модуля
     
     
1 #include <ESP8266WiFi.h>
2 #include <WiFiClientSecure.h>
3 #include <ESP8266HTTPClient.h>
4 #include <ArduinoJson.h>
5 #include "certificate.h"
6 #include "carstatus.h"
7 #include "commands.h"
8 
9 const String WIFI_SSID = "Artem";
10 const String WIFI_PASS = "12345678";
11 
12 const String HOST = "https://autocabserver20240420160507.azurewebsites.net";
13 const String GET_ACTIVE_TRIP_LOCATION_ENDPOINT = "/api/trip/active-trip-location?deviceId=";
14 const String UPDATE_CAR_ENDPOINT = "/api/car/update";
15 const String GET_DOOR_STATUS_ENDPOINT = "/api/car/door-status?deviceId=";
16 const String GET_CAR_STATUS_ENDPOINT = "/api/car/status?deviceId=";
17 const String GET_TRIP_ROUTE_ENDPOINT = "/api/geolocation/route/";
18 const String GET_NEAREST_GAS_STATION_ROUTE_ENDPOINT = "/api/geolocation/gas-station-route?deviceId=";
19 const String GET_ACTIVE_TRIP_SERVICES_ENDPOINT = "/api/trip/active-trip-services?deviceId=";
20 
21 const int DEFAULT_DELAY = 3000;
22 
23 WiFiClientSecure client;
24 HTTPClient https;
25 
26 String currentData;
27 DynamicJsonDocument currentDataJSON(256);
28 
29 String activeTripLocation;
30 DynamicJsonDocument activeTripLocationJSON(48);
31 
32 String activeTripServices;
33 DynamicJsonDocument activeTripServicesJSON(48);
34 
35 String currentRoute;
36 DynamicJsonDocument currentRouteJSON(8192);
37 
38 CarStatus currentStatus;
39 bool isDoorOpen;
40 
41 void setup() {
42   connectToWiFi();
43   updateSystemTime();
44 
45   client.setTrustAnchors(&certificate);
46 
47   Serial.begin(115200);
48   Serial1.begin(115200);
49   
50   while (!Serial) {
51   ; // wait for serial port to connect. Needed for native USB port only
52   }
53 }
54 
55 void loop() {
56   receiveCurrentData();
57 
58   if (!currentData.isEmpty()) {
59     if (deserializeCurrentData()) {
60       currentStatus = (CarStatus)(currentDataJSON["status"].as<int>());
61       
62       if (currentStatus == CarStatus::Idle) {
63         handleActiveTrip();
64         if (!isEnoughFuel()) {
65           handleNearestGasStationRoute();
66         }
67       }
68 
69       if (currentStatus == CarStatus::EnRoute) {
70         handleActiveTrip();
71         handleTripRoute();
72         handleDestination();
73       }
74 
75       if (currentStatus == CarStatus::WaitingForPassenger) {
76         handleDoorStatus();
77         handleCarStatus();
78       }
79 
80       if (currentStatus == CarStatus::OnTrip) {
81         handleCarStatus();
82         handleActiveTrip();
83         handleTripRoute();
84         handleDestination();
85       }
86       
87       sendCarUpdate();
88     }
89   }
90   
91   delay(DEFAULT_DELAY);
92 }
93 
94 void connectToWiFi() {
95   WiFi.begin(WIFI_SSID, WIFI_PASS);
96   while (WiFi.status() != WL_CONNECTED) {
97     delay(500);
98     Serial.print(".");
99   }
100   Serial.println("\nConnected to " + WiFi.localIP().toString());
101 }
102 
103 void updateSystemTime() {
104   // Set time via NTP, as required for x.509 validation
105   configTime(3 * 3600, 0, "pool.ntp.org", "time.nist.gov");
106   time_t now = time(nullptr);
107   while (now < 8 * 3600 * 2) {
108     delay(500);
109     now = time(nullptr);
110   }
111   struct tm timeinfo;
112   gmtime_r(&now, &timeinfo);
113 }
114 
115 void receiveCurrentData() {
116   if (Serial.available()) {
117     currentData = Serial.readString();
118     currentData.trim();
119     Serial.println("Received data: " + currentData);
120   }
121 }
122 
123 bool isEnoughFuel() {
124   return (int)currentDataJSON["fuel"] > 25;
125 }
126 
127 void handleDoorStatus() {
128   String response = getDoorStatus();
129   String command;
130   if (response == DOOR_OPEN_COMMAND) {
131     isDoorOpen = true;
132     command = DOOR_OPEN_COMMAND;
133   } else if (response == DOOR_CLOSED_COMMAND) {
134     isDoorOpen = false;
135     command = DOOR_CLOSED_COMMAND;
136   }
137   Serial1.println(command);
138 }
139 
140 void handleCarStatus() {
141   String response = getCarStatus();
142   String command;
143   if ((CarStatus)response.toInt() == CarStatus::WaitingForPassenger) {
144     command = CAR_STOPPED_COMMAND;
145   }
146   else if ((CarStatus)response.toInt() == CarStatus::OnTrip) {
147     command = CAR_STARTED_COMMAND;
148   }
149   Serial1.println(command);
150 }
151 
152 void handleActiveTrip() {
153   activeTripLocation = getActiveTripLocation();
154   if (deserializeActiveTripLocation()) {
155     Serial1.println(TRIP_ACTIVE_COMMAND);
156   }
157   handleActiveTripServices();
158 }
159 
160 void handleActiveTripServices() {
161   activeTripServices = getActiveTripServices();
162   Serial.println("Active trip services: " + activeTripServices);
163   
164   if (deserializeActiveTripServices()) {
165     String commands = activeTripServicesJSON["commands"];
166     commands.remove(0, 1);
167     commands.remove(commands.length() - 1, 1);
168 
169     int startPos = 0;
170     int commaPos;
171     while (startPos < commands.length()) {
172       commaPos = commands.indexOf(", ", startPos);
173       if (commaPos == -1) {
174           commaPos = commands.length();
175       }
176       String substring = commands.substring(startPos + 1, commaPos - 1);
177       Serial.println(substring);
178       for (int i = 0; i < sizeof(SERVICES_COMMANDS) / sizeof(SERVICES_COMMANDS[0]); i++) {
179           if (SERVICES_COMMANDS[i] == substring) {
180             Serial1.println(substring);
181             break;
182           }
183       }
184       startPos = commaPos + 2; 
185     }
186   }
187 }
188 
189 void handleTripRoute() {
190   if (currentRouteJSON.isNull() && !activeTripLocationJSON.isNull()) {
191     currentRoute = getTripRoute();
192     deserializeCurrentRoute();
193     Serial.println("Current route: " + currentRoute);
194   }
195 }
196 
197 void handleDestination() {
198   double currentX = currentDataJSON["location"]["x"];
199   double currentY = currentDataJSON["location"]["y"];
200   double destinationX = activeTripLocationJSON["x"];
201   double destinationY = activeTripLocationJSON["y"];
202 
203   Serial.println("currentX: " + (String)currentX + ", currentY: " + currentY + ", destination: " + destinationX + ", destinationY: " + destinationY);
204   
205   double tolerance = 0.01;
206 
207   if (fabs(currentX - destinationX) <= tolerance && fabs(currentY - destinationY) <= tolerance) {
208     Serial1.println(DESTINATION_REACHED_COMMAND);
209   }
210 }
211 
212 void handleNearestGasStationRoute() {
213   currentRoute = getNearestGasStationRoute();
214   deserializeCurrentRoute();
215   Serial.println("Current route: " + currentRoute);
216   String command = LOW_FUEL_COMMAND;
217   Serial1.println(command);
218 }
219 
220 String getActiveTripLocation() {
221   String request = HOST + GET_ACTIVE_TRIP_LOCATION_ENDPOINT + currentDataJSON["deviceId"].as<String>();
222   return performHttpGet(request);
223 }
224 
225 String getActiveTripServices() {
226   String request = HOST + GET_ACTIVE_TRIP_SERVICES_ENDPOINT + currentDataJSON["deviceId"].as<String>();
227   return performHttpGet(request);
228 }
229 
230 String getDoorStatus() {
231   String request = HOST + GET_DOOR_STATUS_ENDPOINT + currentDataJSON["deviceId"].as<String>();
232   return performHttpGet(request);
233 }
234 
235 String getCarStatus() {
236   String request = HOST + GET_CAR_STATUS_ENDPOINT + currentDataJSON["deviceId"].as<String>();
237   return performHttpGet(request);
238 }
239 
240 String getTripRoute() {
241   String currentCoordinates = String(currentDataJSON["location"]["x"].as<float>()) + "," + 
242                               String(currentDataJSON["location"]["y"].as<float>());
243 
244   String destinationCoordinates = String(activeTripLocationJSON["x"].as<float>()) + "," +
245                                   String(activeTripLocationJSON["y"].as<float>());
246 
247   String request = HOST + GET_TRIP_ROUTE_ENDPOINT + currentCoordinates + ";" + destinationCoordinates;
248   return performHttpGet(request);
249 }
250 
251 String getNearestGasStationRoute() {
252   String request = HOST + GET_NEAREST_GAS_STATION_ROUTE_ENDPOINT + currentDataJSON["deviceId"].as<String>();
253   return performHttpGet(request);
254 }
255 
256 String performHttpGet(String request) {
257   if (WiFi.status() != WL_CONNECTED) {
258     Serial.printf("[HTTPS] Unable to connect\n");
259     return "";
260   }
261 
262   Serial.print("[HTTPS] begin...\n");
263 
264   if (https.begin(client, request)) {
265     Serial.print("[HTTPS] GET...\n");
266 
267     int httpCode = https.GET();
268 
269     // httpCode will be negative on error
270     if (httpCode > 0) {
271       Serial.printf("[HTTPS] GET... code: %d\n", httpCode);
272 
273       if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {
274         String payload = https.getString();
275         Serial.println(payload);
276         deserializeJson(currentRouteJSON, https.getStream());
277         return payload;
278       }
279     } else {
280       Serial.printf("[HTTPS] GET... failed, error: %s\n", https.errorToString(httpCode).c_str());
281     }
282 
283     https.end();
284   }
285   return "";
286 }
287 
288 void sendCarUpdate() {
289   if (currentDataJSON["isDoorOpen"] != isDoorOpen) {
290     return;
291   }
292   
293   if ((WiFi.status() != WL_CONNECTED)) {
294     Serial.printf("[HTTPS] Unable to connect\n");
295     return;
296   }
297 
298   Serial.print("[HTTPS] begin...\n");
299 
300   String request = HOST + UPDATE_CAR_ENDPOINT;
301 
302   if (https.begin(client, request)) {
303 
304     https.addHeader("Content-Type", "application/json");
305     Serial.print("[HTTP] POST...\n");
306     
307     int httpCode = https.POST(currentData);
308 
309     // httpCode will be negative on error
310     if (httpCode > 0) {
311       Serial.printf("[HTTPS] POST... code: %d\n", httpCode);
312 
313       if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {
314         String payload = https.getString();
315         Serial.println(payload);
316       }
317     } else {
318       Serial.printf("[HTTPS] POST... failed, error: %s\n", https.errorToString(httpCode).c_str());
319     }
320 
321     https.end();
322   }
323 }
324 
325 bool deserializeCurrentData() {
326   return deserializeJsonData(currentDataJSON, currentData);
327 }
328 
329 bool deserializeActiveTripLocation() {
330   return deserializeJsonData(activeTripLocationJSON, activeTripLocation);
331 }
332 
333 bool deserializeActiveTripServices() {
334   return deserializeJsonData(activeTripServicesJSON, activeTripServices);
335 }
336 
337 bool deserializeCurrentRoute() {
338   return deserializeJsonData(currentRouteJSON, currentRoute);
339 }
340 
341 bool deserializeJsonData(DynamicJsonDocument &doc, String &data) {
342   Serial.println("Deserializing data:");
343   Serial.println(data);
344   DeserializationError error = deserializeJson(doc, data);
345   if (error) {
346     Serial.print(F("Deserialization failed: "));
347     Serial.println(error.f_str());
348     return false;
349   }
350   return true;
351 }
     

ДОДАТОК Г
Програмний код клієнтської частини
     Г.1 Код сторінки з панеллю адміністратора
     
     
1 const AdminDashboard = () => {
2   const { t } = useTranslation();
3   const { auth } = useAuth();
4   const { CarStatusColors, CarStatusLabels, TripStatusColors, TripStatusLabels } = useStatusConverter();
5   const [cars, setCars] = useState<GridCar[]>();
6   const [users, setUsers] = useState<GridUser[]>();
7   const [trips, setTrips] = useState<GridTrip[]>();
8   const [services, setServices] = useState<GridService[]>();
9   const [certificate, setCertificate] = useState<CertificateInfoDto>();
10   const [isModalOpen, setIsModalOpen] = useState(false);
11   const [saveStatus, setSaveStatus] = useState<'success' | 'error' | null>(null);
12   const [selectedCar, setSelectedCar] = useState<GridCar>();
13  
14   const handleExportData = async () => {
15     try {
16       const response = await dataService.exportData(auth.bearer!);
17       
18       const link = document.createElement('a');
19       const blob = new Blob([response]);
20 
21       link.href = window.URL.createObjectURL(blob);
22       link.download = 'database.tar';
23       link.click();
24       window.URL.revokeObjectURL(link.href);
25     } catch (error) {
26       console.error('Error exporting data', error);
27     }
28   };
29 
30   const handleImportDatabase = async (file: File) => {
31     if (file == null) {
32       return;
33     }
34     try {
35       const response = await dataService.importData(file, auth.bearer!);
36       setSaveStatus('success');
37     } catch (error) {
38       console.error('Error importing database:', error);
39       setSaveStatus('error');
40     }
41   }
42 
43   const handleExportCertificate = async () => {
44     try {
45       const response = await certificateService.exportCertificate(auth.bearer!);
46 
47       const link = document.createElement('a');
48       const blob = new Blob([response]);
49 
50       link.href = window.URL.createObjectURL(blob);
51       link.download = 'certificate.pfx';
52       link.click();
53       window.URL.revokeObjectURL(link.href);
54     } catch (error) {
55       console.error('Error exporting data', error);
56     }
57   };
58 
59   const handleImportCertificate = async (file: File) => {
60     if (file == null) {
61       return;
62     }
63     try {
64       const response = await certificateService.importCertificate(file, auth.bearer!);
65       setSaveStatus('success');
66     } catch (error) {
67       console.error('Error importing database:', error);
68       setSaveStatus('error');
69     }
70   }
71 
72   const handleSelectionChange = (rowSelectionModel: GridRowSelectionModel) => {
73     const selectedCarId = rowSelectionModel.at(0);
74     setSelectedCar(cars?.find((car) => car.id === selectedCarId))
75   }
76 
77   useEffect(() => {
78     const fetchCars = async () => {
79       try {
80         const response = await carService.getCars();
81         setCars(response);
82       } catch (error) {
83         console.error('Error fetching cars:', error);
84       }
85     };
86 
87     const fetchUsers = async () => {
88       try {
89         const response = await userService.getUsers(auth.bearer!);
90         setUsers(response);
91       } catch (error) {
92         console.error('Error fetching users:', error);
93       }
94     };
95 
96     const fetchTrips = async () => {
97       try {
98         const response = await tripService.getTrips(auth.bearer!);
99         setTrips(response);
100       } catch (error) {
101         console.error('Error fetching trips:', error);
102       }
103     };
104 
105     const fetchServices = async () => {
106       try {
107         const response = await tripService.getServices();
108         setServices(response);
109       } catch (error) {
110         console.error('Error fetching services:', error);
111       }
112     };
113 
114     fetchCars();
115     fetchUsers();
116     fetchTrips();
117     fetchServices();
118   }, [auth.bearer]) 
119 
120   useEffect(() => {
121     const fetchCertificate = async () => {
122       try {
123         const response = await certificateService.getCertificateInfo(auth.bearer!);
124         setCertificate(response);
125       } catch (error) {
126         console.error('Error fetching certificate:', error);
127       }
128     };
129 
130     fetchCertificate();
131   }, [auth.bearer, certificate]) 
132 
133   const handleCloseSnackbar = (event?: React.SyntheticEvent | Event, reason?: string) => {
134     if (reason === 'clickaway') {
135       return;
136     }
137     setSaveStatus(null);
138   };
139 
140   const saveChanges = async () => {
141     try {
142       for (const car of cars) {
143         if (car.isNew) {
144           await carService.createCar(
145             car.brand,
146             car.model,
147             car.licencePlate,
148             car.passengerSeatsNum,
149             car.deviceId,
150             auth.bearer
151           );
152         }
153         else {
154           await carService.editCar(
155             auth.bearer,
156             car.id,
157             car.brand,
158             car.model,
159             car.licencePlate,
160             car.passengerSeatsNum,
161             car.deviceId,
162           );
163         }
164       }
165       for (const user of users) {
166         if (user.isNew) {
167           if (user.role === 'customer') {
168             await authService.signUpCustomer(
169               user.email,
170               'password',
171               user.firstName,
172               user.lastName,
173               user.phoneNumber
174             );
175           }
176           if (user.role === 'admin') {
177             await authService.signUpAdmin(
178               user.email,
179               'password',
180               user.firstName,
181               user.lastName,
182               user.phoneNumber
183             );
184           }
185         }
186       }
187       for (const service of services) {
188         if (service.isNew) {
189           await tripService.createService(
190             service.name,
191             service.command,
192             auth.bearer
193           );
194         }
195         else {
196           await tripService.editService(
197             auth.bearer,
198             service.id,
199             service.name,
200             service.command
201           );
202         }
203       }
204       setSaveStatus('success');
205     } catch (error) {
206       console.error('Error:', error);
207       setSaveStatus('error');
208     }
209   };
210 
211   const handleCloseModal = () => {
212     setIsModalOpen(false);
213   };
214 
215   return (
216     <Container>
217       <Typography variant="h5" gutterBottom align="center" mt={3} mb={2}>
218         {t("adminDashboard")}
219       </Typography>
220       <Paper elevation={3} style={{ padding: '20px', paddingBottom: '20px' }}>
221         <Box mb={2} display="flex" flexDirection="column">
222           <Typography variant="h6" gutterBottom mb={2}>
223             {t("exportImportData")}
224           </Typography>
225           <Box mb={2} display="flex" flexDirection="row" gap="20px">
226             <Button variant="contained" color="primary" onClick={handleExportData}>
227               {t("exportDatabase")}
228             </Button>
229             <Button
230               variant="contained"
231               component="label"
232             >
233               {t("importDatabase")}
234               <input
235                 type="file"
236                 hidden
237                 onChange={(event) => handleImportDatabase(event.target.files[0])}
238               />
239             </Button>
240           </Box>
241         </Box>
242         <Divider />
243         <Typography variant="h6" gutterBottom mt={2}>
244           {t("certificateManagement")}
245         </Typography>
246         <Table sx={{ mb: 2 }}>
247           <TableHead>
248             <TableRow>
249               <TableCell>{t("subject")}</TableCell>
250               <TableCell>{t("issuer")}</TableCell>
251               <TableCell>{t("issuedDate")}</TableCell>
252               <TableCell>{t("expiryDate")}</TableCell>
253               <TableCell>{t("thumbprint")}</TableCell>
254             </TableRow>
255           </TableHead>
256           <TableBody>
257             <TableRow>
258               <TableCell>{certificate?.subject}</TableCell>
259               <TableCell>{certificate?.issuer}</TableCell>
260               <TableCell>{certificate?.issuedDate?.toLocaleString()}</TableCell>
261               <TableCell>{certificate?.expiryDate?.toLocaleString()}</TableCell>
262               <TableCell>{certificate?.thumbprint}</TableCell>
263             </TableRow>
264           </TableBody>
265         </Table>
266         <Box mb={2} display="flex" flexDirection="row" gap="20px">
267           <Button variant="contained" color="primary" onClick={handleExportCertificate}>
268             {t("exportCertificate")}
269           </Button>
270           <Button
271             variant="contained"
272             component="label"
273           >
274             {t("importCertificate")}
275             <input
276               type="file"
277               hidden
278               onChange={(event) => handleImportCertificate(event.target.files[0])}
279             />
280           </Button>
281         </Box>
282         <Divider />
283         <Typography variant="h6" gutterBottom mt={2} mb={2}>
284           {t("users")}
285         </Typography>
286         <EditableDataGrid
287           toolbar={EditToolbar}
288           toolbarProps={{
289             setModal: setIsModalOpen,
290             rows: users || [],
291             setRows: setUsers
292           }}
293           rows={users || []}
294           setRows={setUsers}
295           initialColumns={userColumns}
296         />
297         <Divider />
298         <Typography variant="h6" gutterBottom mt={2} mb={2}>
299           {t("trips")}
300         </Typography>
301         <EditableDataGrid
302           toolbar={EditToolbar}
303           toolbarProps={{
304             setModal: setIsModalOpen,
305             rows: trips || [],
306             setRows: setTrips
307           }}
308           rows={trips || []}
309           setRows={setTrips}
310           initialColumns={tripColumns}
311         />
312         <Divider />
313         <Typography variant="h6" gutterBottom mt={2} mb={2}>
314           {t("services")}
315         </Typography>
316         <EditableDataGrid
317           toolbar={EditToolbar}
318           toolbarProps={{
319             setModal: setIsModalOpen,
320             rows: services || [],
321             setRows: setServices
322           }}
323           rows={services || []}
324           setRows={setServices}
325           initialColumns={serviceColumns}
326         />
327         <Divider />
328         <Typography variant="h6" gutterBottom mt={2} mb={2}>
329           {t("cars")}
330         </Typography>
331         <EditableDataGrid
332           toolbar={CarEditToolbar}
333           toolbarProps={{
334             setModal: setIsModalOpen,
335             rows: cars || [],
336             setRows: setCars
337           }}
338           rows={cars || []}
339           setRows={setCars}
340           initialColumns={carColumns}
341           handleSelectionChange={handleSelectionChange}
342         />
343         <Divider />
344         <Box sx={{ mt: 4 }} display="flex" justifyContent="center">
345           <Button variant="contained" color="primary" onClick={saveChanges}>
346             {t("saveChanges")}
347           </Button>
348           <Snackbar
349             open={saveStatus !== null}
350             autoHideDuration={5000}
351             onClose={handleCloseSnackbar}
352           >
353             <Alert
354               elevation={6}
355               variant="filled"
356               severity={(saveStatus === 'success' || saveStatus === null) ? 'success' : 'error'}
357               onClose={handleCloseSnackbar}
358             >
359               {saveStatus === 'success' || saveStatus === null
360                 ? t("changesSaved")
361                 : t("errorSavingChanges")
362               }
363             </Alert>
364           </Snackbar>
365         </Box>
366       </Paper>
367       <CarLocationModal open={isModalOpen} handleClose={handleCloseModal} selectedCar={selectedCar} />
368     </Container>
369   );
370 };
371 
372 export default AdminDashboard;
     
     
     Г.2 Код сервісу для отримання даних про автомобілі


1 import axios from "axios";
2 import apiClient from "../config/apiClient";
3 import { AddressDto } from "../interfaces/address";
4 import { CarForTripDto, CarInfoDto, CreateCarCommand, EditCarCommand, GetCarsForTripQuery } from "../interfaces/car";
5 
6 const getCars = async (
7 ): Promise<CarInfoDto[]> => {
8   try {
9     const response = await apiClient.get<CarInfoDto[]>(
10       'api/Car/cars'
11     );
12     return response.data;
13   } catch (error) {
14     if (axios.isAxiosError(error)) {
15       throw new Error(error.response?.data.message);
16     } else {
17       throw new Error("Unknown error occurred.");
18     }
19   }
20 };
21 
22 const getCarsForTrip = async (
23   startAddress: AddressDto,
24   destinationAddress: AddressDto,
25   bearerToken: string
26 ): Promise<CarForTripDto[]> => {
27   try {
28     const request: GetCarsForTripQuery = {
29       startAddress,
30       destinationAddress
31     }
32     const headers = {
33       'Authorization': 'Bearer ' + bearerToken
34     };
35     const response = await apiClient.post<CarForTripDto[]>(
36       'api/Car/cars-for-trip',
37       request,
38       { headers }
39     );
40     return response.data;
41   } catch (error) {
42     if (axios.isAxiosError(error)) {
43       throw new Error(error.response?.data.message);
44     } else {
45       throw new Error("Unknown error occurred.");
46     }
47   }
48 };
49 
50 const getCar = async (
51   carId: string
52 ): Promise<CarInfoDto> => {
53   try {
54     const response = await apiClient.get<CarInfoDto>(
55       'api/Car/car?carId=' + carId
56     );
57     return response.data;
58   } catch (error) {
59     if (axios.isAxiosError(error)) {
60       throw new Error(error.response?.data.message);
61     } else {
62       throw new Error("Unknown error occurred.");
63     }
64   }
65 };
66 
67 const createCar = async (
68   brand: string,
69   model: string,
70   licencePlate: string,
71   passengerSeatsNum: number,
72   deviceId: string,
73   bearerToken: string
74 ): Promise<CarInfoDto> => {
75   try {
76     const request: CreateCarCommand = { 
77       brand,
78       model,
79       licencePlate,
80       passengerSeatsNum,
81       deviceId
82     }
83     const headers = {
84       'Authorization': 'Bearer ' + bearerToken
85     };
86     const response = await apiClient.post<CarInfoDto>(
87       'api/Car/create',
88       request,
89       { headers }
90     );
91     return response.data;
92   } catch (error) {
93     if (axios.isAxiosError(error)) {
94       throw new Error(error.response?.data.message);
95     } else {
96       throw new Error("Unknown error occurred.");
97     }
98   }
99 };
100 
101 const editCar = async (
102   bearerToken: string,
103   id?: string,
104   brand?: string,
105   model?: string,
106   licencePlate?: string,
107   passengerSeatsNum?: number,
108   deviceId?: string,
109 ): Promise<CarInfoDto> => {
110   try {
111     const request: EditCarCommand = { 
112       id,
113       brand,
114       model,
115       licencePlate,
116       passengerSeatsNum,
117       deviceId
118     }
119     const headers = {
120       'Authorization': 'Bearer ' + bearerToken
121     };
122     const response = await apiClient.post<CarInfoDto>(
123       'api/Car/edit',
124       request,
125       { headers }
126     );
127     return response.data;
128   } catch (error) {
129     if (axios.isAxiosError(error)) {
130       throw new Error(error.response?.data.message);
131     } else {
132       throw new Error("Unknown error occurred.");
133     }
134   }
135 };
136 
137 const carService = {
138   getCars,
139   getCarsForTrip,
140   getCar,
141   createCar,
142   editCar
143 };
144 
145 export default carService;


     Г.3 Код компонента мапи, який відображає поточне місцезнаходження автомобіля


1 import mapboxgl from "mapbox-gl";
2 import "mapbox-gl/dist/mapbox-gl.css";
3 import React, { useEffect, useState } from "react";
4 
5 
6 interface MapboxMapProps {
7   routeCoordinates: number[][];
8   currentLocation: number[];
9 }
10 
11 const MapboxMap: React.FC<MapboxMapProps> = ({ currentLocation }) => {
12   const [map, setMap] = React.useState<mapboxgl.Map>();
13   const [lng, setLng] = useState(0);
14   const [lat, setLat] = useState(0);
15   const [zoom, setZoom] = useState(12);
16 
17   const mapNode = React.useRef(null);
18 
19   useEffect(() => {
20     const node = mapNode.current;
21     if (typeof window === "undefined" || node === null) return;
22 
23     const mapboxMap = new mapboxgl.Map({
24       container: node,
25       accessToken: "pk.eyJ1IjoibG9zZHJldyIsImEiOiJjbHB1eGJkaHgwMHljMmtxeng2NzA4dndxIn0.S4r1YfGRASP85mHPYNjZuQ",
26             style: "mapbox://styles/mapbox/streets-v11",
27       center: currentLocation,
28       zoom: 12
29     });
30 
31     setMap(mapboxMap);
32     
33     mapboxMap.on('load', () => {
34       mapboxMap.on('move', () => {
35         setLng(mapboxMap.getCenter().lng.toFixed(4));
36         setLat(mapboxMap.getCenter().lat.toFixed(4));
37         setZoom(mapboxMap.getZoom().toFixed(2));
38       });
39 
40       new mapboxgl.Marker().setLngLat(currentLocation).addTo(mapboxMap);
41     });
42 
43     return () => {
44       mapboxMap.remove();
45     };
46   }, []);
47 
48   return ( 
49     <div>
50       <div className="sidebar">
51         Longitude: {lng} | Latitude: {lat} | Zoom: {zoom}
52       </div>
53       <div ref={mapNode} style={{ width: "500px", height: "500px" }} />
54     </div>
55   );
56 };
57 
58 export default MapboxMap;
     4
     
